{
  "title": "Moja Pierwsza Aplikacja Android - Planner",
  "subtitle": "Kurs Kotlin dla M≈Çodych Programist√≥w",
  "introduction": {
    "pl": {
      "title": "Stw√≥rz swojƒÖ pierwszƒÖ aplikacjƒô Android - Planner zada≈Ñ!",
      "content": "W tym kursie nauczysz siƒô programowaƒá w jƒôzyku Kotlin i stworzyƒá prawdziwƒÖ aplikacjƒô na telefon! Bƒôdziemy budowaƒá planner - aplikacjƒô, kt√≥ra pomo≈ºe Ci organizowaƒá zadania, przypominaƒá o wa≈ºnych sprawach i planowaƒá dzie≈Ñ. Od prostego \"Hello World\" do pe≈Çnoprawnej aplikacji z listami, kolorami i powiadomieniami!",
      "goal": "Stworzenie dzia≈ÇajƒÖcej aplikacji planner na Android, kt√≥ra pomo≈ºe organizowaƒá zadania i naukƒô.",
      "example": "Na ko≈Ñcu bƒôdziesz mia≈Ç aplikacjƒô, w kt√≥rej mo≈ºesz:\n‚Ä¢ Dodawaƒá zadania do zrobienia\n‚Ä¢ Oznaczaƒá je jako uko≈Ñczone\n‚Ä¢ Sortowaƒá wed≈Çug kategorii (szko≈Ça, dom, hobby)\n‚Ä¢ Ustawiaƒá przypomnienia"
    },
    "en": {
      "title": "Create your first Android app - Task Planner!",
      "content": "In this course, you'll learn to program in Kotlin and create a real phone app! We'll build a planner - an app that will help you organize tasks, remind you of important things, and plan your day. From simple \"Hello World\" to a full-featured app with lists, colors, and notifications!",
      "goal": "Creating a working Android planner app that helps organize tasks and learning.",
      "example": "At the end, you'll have an app where you can:\n‚Ä¢ Add tasks to do\n‚Ä¢ Mark them as completed\n‚Ä¢ Sort by category (school, home, hobby)\n‚Ä¢ Set reminders"
    },
    "buttonText": "Zaczynamy przygodƒô z Android! üöÄ"
  },
  "steps": [
    {
      "id": "step-1",
      "pl": {
        "title": "Krok 1: Poznajemy Android Studio",
        "intro": "Android Studio to specjalny program, w kt√≥rym tworzymy aplikacje na telefony z systemem Android. To jak warsztat dla programist√≥w! Najpierw musimy go zainstalowaƒá i uruchomiƒá.",
        "code": "// Nasz pierwszy projekt!\n// W Android Studio tworzymy nowy projekt:\n// 1. File -> New -> New Project\n// 2. Wybieramy \"Empty Activity\"\n// 3. Nazywamy projekt \"MojPlanner\"\n// 4. Wybieramy jƒôzyk Kotlin\n\nprintln(\"Witaj w Android Studio!\")",
        "explanation": "Ten kod to nasze pierwsze kroki! Android Studio pomo≈ºe nam stworzyƒá aplikacjƒô krok po kroku. <strong>Empty Activity</strong> to pusty ekran, na kt√≥rym bƒôdziemy budowaƒá naszƒÖ aplikacjƒô."
      },
      "en": {
        "title": "Step 1: Getting to know Android Studio",
        "intro": "Android Studio is a special program where we create apps for Android phones. It's like a workshop for programmers! First, we need to install and run it.",
        "code": "// Our first project!\n// In Android Studio we create a new project:\n// 1. File -> New -> New Project\n// 2. Choose \"Empty Activity\"\n// 3. Name the project \"MyPlanner\"\n// 4. Choose Kotlin language\n\nprintln(\"Welcome to Android Studio!\")",
        "explanation": "This code is our first steps! Android Studio will help us create an app step by step. <strong>Empty Activity</strong> is an empty screen where we'll build our application."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-2",
      "pl": {
        "title": "Krok 2: Pierwszy tekst na ekranie",
        "intro": "Ka≈ºda aplikacja zaczyna siƒô od wy≈õwietlenia czego≈õ na ekranie. Zmienimy domy≈õlny tekst \"Hello World\" na powitanie dla naszego plannera.",
        "code": "// W pliku activity_main.xml zmieniamy tekst:\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Witaj w Moim Plannerze!\"\n    android:textSize=\"24sp\"\n    android:layout_centerInParent=\"true\" />",
        "explanation": "<strong>TextView</strong> to element, kt√≥ry wy≈õwietla tekst na ekranie. <strong>android:text</strong> okre≈õla, jaki tekst ma byƒá pokazany, a <strong>android:textSize</strong> ustawia wielko≈õƒá czcionki."
      },
      "en": {
        "title": "Step 2: First text on screen",
        "intro": "Every app starts by displaying something on screen. We'll change the default \"Hello World\" text to a greeting for our planner.",
        "code": "// In activity_main.xml file we change the text:\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Welcome to My Planner!\"\n    android:textSize=\"24sp\"\n    android:layout_centerInParent=\"true\" />",
        "explanation": "<strong>TextView</strong> is an element that displays text on screen. <strong>android:text</strong> specifies what text should be shown, and <strong>android:textSize</strong> sets the font size."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-3",
      "pl": {
        "title": "Krok 3: Dodajemy kolory",
        "intro": "Kolorowa aplikacja jest bardziej przyjazna! Dodamy ≈Çadne kolory do naszego tekstu i t≈Ça.",
        "code": "// W pliku activity_main.xml dodajemy kolory:\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Witaj w Moim Plannerze!\"\n    android:textSize=\"24sp\"\n    android:textColor=\"#2196F3\"\n    android:background=\"#E3F2FD\"\n    android:padding=\"16dp\"\n    android:layout_centerInParent=\"true\" />",
        "explanation": "<strong>android:textColor</strong> zmienia kolor tekstu (tu niebieski), a <strong>android:background</strong> ustawia kolor t≈Ça (jasnoniebieski). <strong>android:padding</strong> dodaje odstƒôp wok√≥≈Ç tekstu."
      },
      "en": {
        "title": "Step 3: Adding colors",
        "intro": "A colorful app is more friendly! We'll add nice colors to our text and background.",
        "code": "// In activity_main.xml file we add colors:\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Welcome to My Planner!\"\n    android:textSize=\"24sp\"\n    android:textColor=\"#2196F3\"\n    android:background=\"#E3F2FD\"\n    android:padding=\"16dp\"\n    android:layout_centerInParent=\"true\" />",
        "explanation": "<strong>android:textColor</strong> changes text color (here blue), and <strong>android:background</strong> sets background color (light blue). <strong>android:padding</strong> adds space around the text."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-4",
      "pl": {
        "title": "Krok 4: Pierwszy przycisk",
        "intro": "Aplikacje potrzebujƒÖ przycisk√≥w, ≈ºeby u≈ºytkownik m√≥g≈Ç co≈õ robiƒá! Dodamy przycisk do naszego plannera.",
        "code": "// W activity_main.xml dodajemy przycisk:\n<Button\n    android:id=\"@+id/buttonStart\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Rozpocznij planowanie\"\n    android:layout_below=\"@id/textView\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"20dp\" />",
        "explanation": "<strong>Button</strong> to element, na kt√≥ry mo≈ºna kliknƒÖƒá. <strong>android:id</strong> daje przyciskowi nazwƒô, ≈ºeby≈õmy mogli siƒô do niego odwo≈Çywaƒá w kodzie Kotlin."
      },
      "en": {
        "title": "Step 4: First button",
        "intro": "Apps need buttons so users can do something! We'll add a button to our planner.",
        "code": "// In activity_main.xml we add a button:\n<Button\n    android:id=\"@+id/buttonStart\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Start planning\"\n    android:layout_below=\"@id/textView\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"20dp\" />",
        "explanation": "<strong>Button</strong> is an element you can click on. <strong>android:id</strong> gives the button a name so we can refer to it in Kotlin code."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-5",
      "pl": {
        "title": "Krop 5: Akcja po klikniƒôciu przycisku",
        "intro": "Przycisk bez akcji to jak samoch√≥d bez silnika! Napiszemy kod Kotlin, kt√≥ry wykona siƒô po klikniƒôciu przycisku.",
        "code": "// W pliku MainActivity.kt dodajemy akcjƒô:\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val buttonStart = findViewById<Button>(R.id.buttonStart)\n        buttonStart.setOnClickListener {\n            Toast.makeText(this, \"Zaczynamy planowaƒá!\", Toast.LENGTH_SHORT).show()\n        }\n    }\n}",
        "explanation": "<strong>findViewById</strong> znajduje nasz przycisk po ID. <strong>setOnClickListener</strong> okre≈õla, co ma siƒô staƒá po klikniƒôciu. <strong>Toast</strong> to kr√≥tka wiadomo≈õƒá wy≈õwietlana na ekranie."
      },
      "en": {
        "title": "Step 5: Action after button click",
        "intro": "A button without action is like a car without an engine! We'll write Kotlin code that executes when the button is clicked.",
        "code": "// In MainActivity.kt file we add action:\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val buttonStart = findViewById<Button>(R.id.buttonStart)\n        buttonStart.setOnClickListener {\n            Toast.makeText(this, \"Let's start planning!\", Toast.LENGTH_SHORT).show()\n        }\n    }\n}",
        "explanation": "<strong>findViewById</strong> finds our button by ID. <strong>setOnClickListener</strong> defines what should happen after clicking. <strong>Toast</strong> is a short message displayed on screen."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-6",
      "pl": {
        "title": "Krok 6: Pole do wpisywania tekstu",
        "intro": "≈ªeby dodawaƒá zadania do plannera, potrzebujemy miejsca, gdzie u≈ºytkownik mo≈ºe wpisaƒá tekst. Dodamy pole tekstowe!",
        "code": "// W activity_main.xml dodajemy pole tekstowe:\n<EditText\n    android:id=\"@+id/editTextTask\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"Wpisz swoje zadanie...\"\n    android:layout_margin=\"16dp\"\n    android:padding=\"12dp\"\n    android:background=\"@drawable/rounded_border\" />",
        "explanation": "<strong>EditText</strong> to pole, w kt√≥re u≈ºytkownik mo≈ºe wpisywaƒá tekst. <strong>android:hint</strong> pokazuje podpowied≈∫, co wpisaƒá. <strong>match_parent</strong> sprawia, ≈ºe pole rozciƒÖga siƒô na ca≈ÇƒÖ szeroko≈õƒá."
      },
      "en": {
        "title": "Step 6: Text input field",
        "intro": "To add tasks to the planner, we need a place where the user can type text. Let's add a text field!",
        "code": "// In activity_main.xml we add a text field:\n<EditText\n    android:id=\"@+id/editTextTask\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"Enter your task...\"\n    android:layout_margin=\"16dp\"\n    android:padding=\"12dp\"\n    android:background=\"@drawable/rounded_border\" />",
        "explanation": "<strong>EditText</strong> is a field where users can type text. <strong>android:hint</strong> shows a suggestion of what to type. <strong>match_parent</strong> makes the field stretch to full width."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-7",
      "pl": {
        "title": "Krok 7: Zmienna do przechowywania zada≈Ñ",
        "intro": "Komputer musi gdzie≈õ pamiƒôtaƒá nasze zadania! Stworzymy zmiennƒÖ, kt√≥ra bƒôdzie przechowywaƒá listƒô wszystkich zada≈Ñ.",
        "code": "// W MainActivity.kt dodajemy zmiennƒÖ dla zada≈Ñ:\nclass MainActivity : AppCompatActivity() {\n    \n    // Lista do przechowywania zada≈Ñ\n    private val taskList = mutableListOf<String>()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Dodajemy przyk≈Çadowe zadanie\n        taskList.add(\"Przyk≈Çadowe zadanie\")\n    }\n}",
        "explanation": "<strong>mutableListOf<String>()</strong> tworzy listƒô, kt√≥rƒÖ mo≈ºna zmieniaƒá. <strong>private val</strong> oznacza, ≈ºe tylko ta klasa mo≈ºe u≈ºywaƒá tej zmiennej. <strong>add()</strong> dodaje nowy element do listy."
      },
      "en": {
        "title": "Step 7: Variable to store tasks",
        "intro": "The computer needs to remember our tasks somewhere! We'll create a variable that will store a list of all tasks.",
        "code": "// In MainActivity.kt we add a variable for tasks:\nclass MainActivity : AppCompatActivity() {\n    \n    // List to store tasks\n    private val taskList = mutableListOf<String>()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Add example task\n        taskList.add(\"Example task\")\n    }\n}",
        "explanation": "<strong>mutableListOf<String>()</strong> creates a list that can be changed. <strong>private val</strong> means only this class can use this variable. <strong>add()</strong> adds a new element to the list."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-8",
      "pl": {
        "title": "Krok 8: Dodawanie zadania z pola tekstowego",
        "intro": "Teraz po≈ÇƒÖczymy pole tekstowe z naszƒÖ listƒÖ zada≈Ñ. Po klikniƒôciu przycisku zadanie zostanie dodane do listy!",
        "code": "// W MainActivity.kt dodajemy funkcjƒô dodawania zadania:\nval buttonAdd = findViewById<Button>(R.id.buttonAdd)\nval editText = findViewById<EditText>(R.id.editTextTask)\n\nbuttonAdd.setOnClickListener {\n    val newTask = editText.text.toString()\n    if (newTask.isNotEmpty()) {\n        taskList.add(newTask)\n        editText.text.clear()\n        Toast.makeText(this, \"Zadanie dodane!\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>editText.text.toString()</strong> pobiera tekst z pola. <strong>isNotEmpty()</strong> sprawdza, czy pole nie jest puste. <strong>clear()</strong> czy≈õci pole po dodaniu zadania."
      },
      "en": {
        "title": "Step 8: Adding task from text field",
        "intro": "Now we'll connect the text field with our task list. After clicking the button, the task will be added to the list!",
        "code": "// In MainActivity.kt we add task adding function:\nval buttonAdd = findViewById<Button>(R.id.buttonAdd)\nval editText = findViewById<EditText>(R.id.editTextTask)\n\nbuttonAdd.setOnClickListener {\n    val newTask = editText.text.toString()\n    if (newTask.isNotEmpty()) {\n        taskList.add(newTask)\n        editText.text.clear()\n        Toast.makeText(this, \"Task added!\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>editText.text.toString()</strong> gets text from the field. <strong>isNotEmpty()</strong> checks if the field is not empty. <strong>clear()</strong> clears the field after adding task."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-9",
      "pl": {
        "title": "Krok 9: Wy≈õwietlanie listy zada≈Ñ",
        "intro": "Dodajemy zadania, ale ich nie widzimy! Czas stworzyƒá listƒô, kt√≥ra poka≈ºe wszystkie nasze zadania na ekranie.",
        "code": "// W activity_main.xml dodajemy ListView:\n<ListView\n    android:id=\"@+id/listViewTasks\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"0dp\"\n    android:layout_weight=\"1\"\n    android:layout_margin=\"16dp\"\n    android:divider=\"#CCCCCC\"\n    android:dividerHeight=\"1dp\" />",
        "explanation": "<strong>ListView</strong> to element, kt√≥ry wy≈õwietla listƒô element√≥w. <strong>layout_weight=\"1\"</strong> sprawia, ≈ºe lista zajmuje ca≈ÇƒÖ dostƒôpnƒÖ przestrze≈Ñ. <strong>divider</strong> dodaje linie miƒôdzy elementami listy."
      },
      "en": {
        "title": "Step 9: Displaying task list",
        "intro": "We're adding tasks but we can't see them! Time to create a list that will show all our tasks on screen.",
        "code": "// In activity_main.xml we add ListView:\n<ListView\n    android:id=\"@+id/listViewTasks\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"0dp\"\n    android:layout_weight=\"1\"\n    android:layout_margin=\"16dp\"\n    android:divider=\"#CCCCCC\"\n    android:dividerHeight=\"1dp\" />",
        "explanation": "<strong>ListView</strong> is an element that displays a list of items. <strong>layout_weight=\"1\"</strong> makes the list take all available space. <strong>divider</strong> adds lines between list items."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-10",
      "pl": {
        "title": "Krok 10: Adapter - ≈ÇƒÖcznik miƒôdzy danymi a listƒÖ",
        "intro": "Lista potrzebuje \"t≈Çumacza\", kt√≥ry powie jej, jak wy≈õwietliƒá nasze zadania. Ten t≈Çumacz nazywa siƒô Adapter!",
        "code": "// W MainActivity.kt dodajemy adapter:\nclass MainActivity : AppCompatActivity() {\n    private val taskList = mutableListOf<String>()\n    private lateinit var adapter: ArrayAdapter<String>\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val listView = findViewById<ListView>(R.id.listViewTasks)\n        adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, taskList)\n        listView.adapter = adapter\n    }\n}",
        "explanation": "<strong>ArrayAdapter</strong> to adapter, kt√≥ry ≈ÇƒÖczy listƒô danych z ListView. <strong>simple_list_item_1</strong> to gotowy uk≈Çad dla prostych element√≥w listy. <strong>lateinit</strong> oznacza, ≈ºe zmienna zostanie zainicjowana p√≥≈∫niej."
      },
      "en": {
        "title": "Step 10: Adapter - connector between data and list",
        "intro": "The list needs a \"translator\" that will tell it how to display our tasks. This translator is called an Adapter!",
        "code": "// In MainActivity.kt we add adapter:\nclass MainActivity : AppCompatActivity() {\n    private val taskList = mutableListOf<String>()\n    private lateinit var adapter: ArrayAdapter<String>\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val listView = findViewById<ListView>(R.id.listViewTasks)\n        adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, taskList)\n        listView.adapter = adapter\n    }\n}",
        "explanation": "<strong>ArrayAdapter</strong> is an adapter that connects data list with ListView. <strong>simple_list_item_1</strong> is a ready layout for simple list items. <strong>lateinit</strong> means the variable will be initialized later."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-11",
      "pl": {
        "title": "Krok 11: Od≈õwie≈ºanie listy po dodaniu zadania",
        "intro": "Gdy dodajemy nowe zadanie, lista musi siƒô od≈õwie≈ºyƒá, ≈ºeby pokazaƒá nowy element. U≈ºywamy do tego specjalnej funkcji!",
        "code": "// Aktualizujemy funkcjƒô dodawania zadania:\nbuttonAdd.setOnClickListener {\n    val newTask = editText.text.toString()\n    if (newTask.isNotEmpty()) {\n        taskList.add(newTask)\n        adapter.notifyDataSetChanged() // Od≈õwie≈ºa listƒô!\n        editText.text.clear()\n        Toast.makeText(this, \"Zadanie dodane: $newTask\", Toast.LENGTH_SHORT).show()\n    } else {\n        Toast.makeText(this, \"Wpisz zadanie!\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>notifyDataSetChanged()</strong> m√≥wi adapterowi, ≈ºe dane siƒô zmieni≈Çy i lista powinna siƒô od≈õwie≈ºyƒá. <strong>$newTask</strong> wstawia warto≈õƒá zmiennej do tekstu."
      },
      "en": {
        "title": "Step 11: Refreshing list after adding task",
        "intro": "When we add a new task, the list must refresh to show the new item. We use a special function for this!",
        "code": "// We update the task adding function:\nbuttonAdd.setOnClickListener {\n    val newTask = editText.text.toString()\n    if (newTask.isNotEmpty()) {\n        taskList.add(newTask)\n        adapter.notifyDataSetChanged() // Refreshes the list!\n        editText.text.clear()\n        Toast.makeText(this, \"Task added: $newTask\", Toast.LENGTH_SHORT).show()\n    } else {\n        Toast.makeText(this, \"Enter a task!\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>notifyDataSetChanged()</strong> tells the adapter that data has changed and the list should refresh. <strong>$newTask</strong> inserts the variable value into text."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-12",
      "pl": {
        "title": "Krok 12: Usuwanie zada≈Ñ przez d≈Çugie klikniƒôcie",
        "intro": "Czasem chcemy usunƒÖƒá zadanie z listy. Dodamy mo≈ºliwo≈õƒá usuwania przez d≈Çugie przytrzymanie palca na zadaniu!",
        "code": "// W onCreate() dodajemy obs≈Çugƒô d≈Çugiego klikniƒôcia:\nlistView.setOnItemLongClickListener { _, _, position, _ ->\n    val taskToRemove = taskList[position]\n    \n    // Tworzymy dialog potwierdzenia\n    AlertDialog.Builder(this)\n        .setTitle(\"Usu≈Ñ zadanie\")\n        .setMessage(\"Czy chcesz usunƒÖƒá: $taskToRemove?\")\n        .setPositiveButton(\"Tak\") { _, _ ->\n            taskList.removeAt(position)\n            adapter.notifyDataSetChanged()\n            Toast.makeText(this, \"Zadanie usuniƒôte\", Toast.LENGTH_SHORT).show()\n        }\n        .setNegativeButton(\"Nie\", null)\n        .show()\n    \n    true\n}",
        "explanation": "<strong>setOnItemLongClickListener</strong> reaguje na d≈Çugie klikniƒôcie. <strong>AlertDialog</strong> tworzy okno potwierdzenia. <strong>removeAt(position)</strong> usuwa element z okre≈õlonej pozycji."
      },
      "en": {
        "title": "Step 12: Deleting tasks with long click",
        "intro": "Sometimes we want to remove a task from the list. We'll add the ability to delete by long pressing on a task!",
        "code": "// In onCreate() we add long click handling:\nlistView.setOnItemLongClickListener { _, _, position, _ ->\n    val taskToRemove = taskList[position]\n    \n    // Create confirmation dialog\n    AlertDialog.Builder(this)\n        .setTitle(\"Delete task\")\n        .setMessage(\"Do you want to delete: $taskToRemove?\")\n        .setPositiveButton(\"Yes\") { _, _ ->\n            taskList.removeAt(position)\n            adapter.notifyDataSetChanged()\n            Toast.makeText(this, \"Task deleted\", Toast.LENGTH_SHORT).show()\n        }\n        .setNegativeButton(\"No\", null)\n        .show()\n    \n    true\n}",
        "explanation": "<strong>setOnItemLongClickListener</strong> responds to long clicks. <strong>AlertDialog</strong> creates a confirmation window. <strong>removeAt(position)</strong> removes element from specific position."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-13",
      "pl": {
        "title": "Krok 13: Klasa Task z wiƒôcej informacjami",
        "intro": "Zamiast prostych tekst√≥w, stworzymy klasƒô Task, kt√≥ra bƒôdzie przechowywaƒá wiƒôcej informacji o ka≈ºdym zadaniu!",
        "code": "// Tworzymy klasƒô Task:\ndata class Task(\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"Og√≥lne\",\n    val priority: Int = 1 // 1=niska, 2=≈õrednia, 3=wysoka\n) {\n    override fun toString(): String {\n        val status = if (isCompleted) \"‚úì\" else \"‚óã\"\n        val priorityIcon = when (priority) {\n            3 -> \"üî¥\"\n            2 -> \"üü°\"\n            else -> \"üü¢\"\n        }\n        return \"$status $priorityIcon $title [$category]\"\n    }\n}",
        "explanation": "<strong>data class</strong> to specjalna klasa do przechowywania danych. <strong>var</strong> oznacza zmiennƒÖ, kt√≥rƒÖ mo≈ºna zmieniaƒá. <strong>override fun toString()</strong> okre≈õla, jak obiekt ma byƒá wy≈õwietlany jako tekst."
      },
      "en": {
        "title": "Step 13: Task class with more information",
        "intro": "Instead of simple texts, we'll create a Task class that will store more information about each task!",
        "code": "// We create Task class:\ndata class Task(\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"General\",\n    val priority: Int = 1 // 1=low, 2=medium, 3=high\n) {\n    override fun toString(): String {\n        val status = if (isCompleted) \"‚úì\" else \"‚óã\"\n        val priorityIcon = when (priority) {\n            3 -> \"üî¥\"\n            2 -> \"üü°\"\n            else -> \"üü¢\"\n        }\n        return \"$status $priorityIcon $title [$category]\"\n    }\n}",
        "explanation": "<strong>data class</strong> is a special class for storing data. <strong>var</strong> means a variable that can be changed. <strong>override fun toString()</strong> defines how the object should be displayed as text."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-14",
      "pl": {
        "title": "Krok 14: Aktualizacja listy do u≈ºywania klasy Task",
        "intro": "Teraz zmienimy naszƒÖ listƒô, ≈ºeby u≈ºywa≈Ça nowej klasy Task zamiast prostych tekst√≥w!",
        "code": "// Aktualizujemy MainActivity:\nclass MainActivity : AppCompatActivity() {\n    private val taskList = mutableListOf<Task>() // Zmiana na Task!\n    private lateinit var adapter: ArrayAdapter<Task>\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Dodajemy przyk≈Çadowe zadania\n        taskList.add(Task(\"Odrobiƒá matematykƒô\", false, \"Szko≈Ça\", 3))\n        taskList.add(Task(\"PosprzƒÖtaƒá pok√≥j\", false, \"Dom\", 2))\n        \n        val listView = findViewById<ListView>(R.id.listViewTasks)\n        adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, taskList)\n        listView.adapter = adapter\n        \n        setupAddButton()\n        setupListClickListeners(listView)\n    }\n}",
        "explanation": "Teraz nasza lista przechowuje obiekty <strong>Task</strong> zamiast prostych tekst√≥w. Ka≈ºde zadanie ma tytu≈Ç, status uko≈Ñczenia, kategoriƒô i priorytet. Funkcja <strong>toString()</strong> automatycznie formatuje wy≈õwietlanie."
      },
      "en": {
        "title": "Step 14: Updating list to use Task class",
        "intro": "Now we'll change our list to use the new Task class instead of simple texts!",
        "code": "// We update MainActivity:\nclass MainActivity : AppCompatActivity() {\n    private val taskList = mutableListOf<Task>() // Change to Task!\n    private lateinit var adapter: ArrayAdapter<Task>\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        // Add example tasks\n        taskList.add(Task(\"Do math homework\", false, \"School\", 3))\n        taskList.add(Task(\"Clean room\", false, \"Home\", 2))\n        \n        val listView = findViewById<ListView>(R.id.listViewTasks)\n        adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, taskList)\n        listView.adapter = adapter\n        \n        setupAddButton()\n        setupListClickListeners(listView)\n    }\n}",
        "explanation": "Now our list stores <strong>Task</strong> objects instead of simple texts. Each task has title, completion status, category and priority. The <strong>toString()</strong> function automatically formats the display."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-15",
      "pl": {
        "title": "Krok 15: Oznaczanie zada≈Ñ jako uko≈Ñczone",
        "intro": "Dodamy mo≈ºliwo≈õƒá oznaczania zada≈Ñ jako uko≈Ñczone przez klikniƒôcie na nie. Uko≈Ñczone zadania bƒôdƒÖ mia≈Çy inny kolor!",
        "code": "// Dodajemy obs≈Çugƒô klikniƒôcia na zadanie:\nlistView.setOnItemClickListener { _, _, position, _ ->\n    val task = taskList[position]\n    task.isCompleted = !task.isCompleted // Prze≈ÇƒÖczamy status\n    \n    adapter.notifyDataSetChanged()\n    \n    val message = if (task.isCompleted) {\n        \"Zadanie uko≈Ñczone: ${task.title}\"\n    } else {\n        \"Zadanie przywr√≥cone: ${task.title}\"\n    }\n    Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\n}",
        "explanation": "<strong>!task.isCompleted</strong> prze≈ÇƒÖcza warto≈õƒá boolean (true na false i odwrotnie). Po klikniƒôciu zadanie zmienia status z nieuko≈Ñczonego na uko≈Ñczone lub odwrotnie."
      },
      "en": {
        "title": "Step 15: Marking tasks as completed",
        "intro": "We'll add the ability to mark tasks as completed by clicking on them. Completed tasks will have a different color!",
        "code": "// Add task click handling:\nlistView.setOnItemClickListener { _, _, position, _ ->\n    val task = taskList[position]\n    task.isCompleted = !task.isCompleted // Toggle status\n    \n    adapter.notifyDataSetChanged()\n    \n    val message = if (task.isCompleted) {\n        \"Task completed: ${task.title}\"\n    } else {\n        \"Task restored: ${task.title}\"\n    }\n    Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\n}",
        "explanation": "<strong>!task.isCompleted</strong> toggles boolean value (true to false and vice versa). After clicking, the task changes status from incomplete to complete or vice versa."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-16",
      "pl": {
        "title": "Krok 16: Spinner do wyboru kategorii",
        "intro": "Dodamy rozwijane menu (Spinner), ≈ºeby u≈ºytkownik m√≥g≈Ç wybraƒá kategoriƒô dla nowego zadania!",
        "code": "// W activity_main.xml dodajemy Spinner:\n<Spinner\n    android:id=\"@+id/spinnerCategory\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_margin=\"16dp\"\n    android:padding=\"12dp\" />\n\n// W MainActivity.kt inicjalizujemy Spinner:\nval spinnerCategory = findViewById<Spinner>(R.id.spinnerCategory)\nval categories = arrayOf(\"Szko≈Ça\", \"Dom\", \"Hobby\", \"Sport\", \"Zakupy\")\nval categoryAdapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, categories)\ncategoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)\nspinnerCategory.adapter = categoryAdapter",
        "explanation": "<strong>Spinner</strong> to rozwijane menu z opcjami do wyboru. <strong>setDropDownViewResource</strong> ustawia wyglƒÖd rozwiniƒôtej listy opcji."
      },
      "en": {
        "title": "Step 16: Spinner for category selection",
        "intro": "We'll add a dropdown menu (Spinner) so the user can choose a category for the new task!",
        "code": "// In activity_main.xml we add Spinner:\n<Spinner\n    android:id=\"@+id/spinnerCategory\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_margin=\"16dp\"\n    android:padding=\"12dp\" />\n\n// In MainActivity.kt we initialize Spinner:\nval spinnerCategory = findViewById<Spinner>(R.id.spinnerCategory)\nval categories = arrayOf(\"School\", \"Home\", \"Hobby\", \"Sport\", \"Shopping\")\nval categoryAdapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, categories)\ncategoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)\nspinnerCategory.adapter = categoryAdapter",
        "explanation": "<strong>Spinner</strong> is a dropdown menu with options to choose from. <strong>setDropDownViewResource</strong> sets the appearance of the expanded option list."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-17",
      "pl": {
        "title": "Krok 17: Slider do wyboru priorytetu",
        "intro": "Dodamy suwak (SeekBar), kt√≥rym u≈ºytkownik bƒôdzie m√≥g≈Ç ustawiƒá priorytet zadania od 1 do 3!",
        "code": "// W activity_main.xml dodajemy SeekBar z etykietƒÖ:\n<TextView\n    android:id=\"@+id/textPriority\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Priorytet: Niski\"\n    android:layout_margin=\"16dp\" />\n\n<SeekBar\n    android:id=\"@+id/seekBarPriority\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:max=\"2\"\n    android:progress=\"0\"\n    android:layout_margin=\"16dp\" />",
        "explanation": "<strong>SeekBar</strong> to suwak, kt√≥rym mo≈ºna wybieraƒá warto≈õci. <strong>android:max=\"2\"</strong> oznacza maksymalnƒÖ warto≈õƒá (0,1,2 = niski,≈õredni,wysoki priorytet)."
      },
      "en": {
        "title": "Step 17: Slider for priority selection",
        "intro": "We'll add a slider (SeekBar) that the user can use to set task priority from 1 to 3!",
        "code": "// In activity_main.xml we add SeekBar with label:\n<TextView\n    android:id=\"@+id/textPriority\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Priority: Low\"\n    android:layout_margin=\"16dp\" />\n\n<SeekBar\n    android:id=\"@+id/seekBarPriority\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:max=\"2\"\n    android:progress=\"0\"\n    android:layout_margin=\"16dp\" />",
        "explanation": "<strong>SeekBar</strong> is a slider for selecting values. <strong>android:max=\"2\"</strong> means maximum value (0,1,2 = low,medium,high priority)."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-18",
      "pl": {
        "title": "Krok 18: Obs≈Çuga suwaka priorytetu",
        "intro": "Dodamy kod, kt√≥ry bƒôdzie reagowaƒá na przesuwanie suwaka i aktualizowaƒá etykietƒô priorytetu!",
        "code": "// W MainActivity.kt dodajemy obs≈Çugƒô SeekBar:\nval seekBarPriority = findViewById<SeekBar>(R.id.seekBarPriority)\nval textPriority = findViewById<TextView>(R.id.textPriority)\n\nseekBarPriority.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {\n    override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {\n        val priorityText = when (progress) {\n            0 -> \"Priorytet: Niski üü¢\"\n            1 -> \"Priorytet: ≈öredni üü°\"\n            2 -> \"Priorytet: Wysoki üî¥\"\n            else -> \"Priorytet: Niski üü¢\"\n        }\n        textPriority.text = priorityText\n    }\n    \n    override fun onStartTrackingTouch(seekBar: SeekBar?) {}\n    override fun onStopTrackingTouch(seekBar: SeekBar?) {}\n})",
        "explanation": "<strong>OnSeekBarChangeListener</strong> reaguje na zmiany suwaka. <strong>when</strong> to Kotlinowy odpowiednik switch - sprawdza r√≥≈ºne warto≈õci i wykonuje odpowiedni kod."
      },
      "en": {
        "title": "Step 18: Handling priority slider",
        "intro": "We'll add code that will react to slider movement and update the priority label!",
        "code": "// In MainActivity.kt we add SeekBar handling:\nval seekBarPriority = findViewById<SeekBar>(R.id.seekBarPriority)\nval textPriority = findViewById<TextView>(R.id.textPriority)\n\nseekBarPriority.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {\n    override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {\n        val priorityText = when (progress) {\n            0 -> \"Priority: Low üü¢\"\n            1 -> \"Priority: Medium üü°\"\n            2 -> \"Priority: High üî¥\"\n            else -> \"Priority: Low üü¢\"\n        }\n        textPriority.text = priorityText\n    }\n    \n    override fun onStartTrackingTouch(seekBar: SeekBar?) {}\n    override fun onStopTrackingTouch(seekBar: SeekBar?) {}\n})",
        "explanation": "<strong>OnSeekBarChangeListener</strong> responds to slider changes. <strong>when</strong> is Kotlin's equivalent of switch - checks different values and executes appropriate code."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-19",
      "pl": {
        "title": "Krok 19: Dodawanie zada≈Ñ z kategoriƒÖ i priorytetem",
        "intro": "Teraz zaktualizujemy funkcjƒô dodawania zada≈Ñ, ≈ºeby u≈ºywa≈Ça wybranej kategorii i priorytetu!",
        "code": "// Aktualizujemy funkcjƒô dodawania zadania:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    \n    if (taskTitle.isNotEmpty()) {\n        val selectedCategory = spinnerCategory.selectedItem.toString()\n        val selectedPriority = seekBarPriority.progress + 1 // +1 bo 0,1,2 -> 1,2,3\n        \n        val newTask = Task(\n            title = taskTitle,\n            isCompleted = false,\n            category = selectedCategory,\n            priority = selectedPriority\n        )\n        \n        taskList.add(newTask)\n        adapter.notifyDataSetChanged()\n        \n        // Czy≈õcimy formularz\n        editText.text.clear()\n        spinnerCategory.setSelection(0)\n        seekBarPriority.progress = 0\n        \n        Toast.makeText(this, \"Dodano: $taskTitle\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>trim()</strong> usuwa bia≈Çe znaki z poczƒÖtku i ko≈Ñca tekstu. <strong>selectedItem.toString()</strong> pobiera wybranƒÖ opcjƒô ze Spinnera. <strong>setSelection(0)</strong> resetuje Spinner do pierwszej opcji."
      },
      "en": {
        "title": "Step 19: Adding tasks with category and priority",
        "intro": "Now we'll update the task adding function to use the selected category and priority!",
        "code": "// We update the task adding function:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    \n    if (taskTitle.isNotEmpty()) {\n        val selectedCategory = spinnerCategory.selectedItem.toString()\n        val selectedPriority = seekBarPriority.progress + 1 // +1 because 0,1,2 -> 1,2,3\n        \n        val newTask = Task(\n            title = taskTitle,\n            isCompleted = false,\n            category = selectedCategory,\n            priority = selectedPriority\n        )\n        \n        taskList.add(newTask)\n        adapter.notifyDataSetChanged()\n        \n        // Clear form\n        editText.text.clear()\n        spinnerCategory.setSelection(0)\n        seekBarPriority.progress = 0\n        \n        Toast.makeText(this, \"Added: $taskTitle\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>trim()</strong> removes whitespace from the beginning and end of text. <strong>selectedItem.toString()</strong> gets the selected option from Spinner. <strong>setSelection(0)</strong> resets Spinner to first option."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-20",
      "pl": {
        "title": "Krok 20: Sortowanie zada≈Ñ wed≈Çug priorytetu",
        "intro": "Dodamy przycisk, kt√≥ry posortuje nasze zadania wed≈Çug priorytetu - najwa≈ºniejsze na g√≥rze!",
        "code": "// W activity_main.xml dodajemy przycisk sortowania:\n<Button\n    android:id=\"@+id/buttonSort\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Sortuj wed≈Çug priorytetu\"\n    android:layout_margin=\"8dp\" />\n\n// W MainActivity.kt dodajemy funkcjƒô sortowania:\nval buttonSort = findViewById<Button>(R.id.buttonSort)\nbuttonSort.setOnClickListener {\n    taskList.sortWith(compareByDescending<Task> { it.priority }.thenBy { it.isCompleted })\n    adapter.notifyDataSetChanged()\n    Toast.makeText(this, \"Lista posortowana!\", Toast.LENGTH_SHORT).show()\n}",
        "explanation": "<strong>sortWith</strong> sortuje listƒô wed≈Çug podanych kryteri√≥w. <strong>compareByDescending</strong> sortuje malejƒÖco (3,2,1). <strong>thenBy</strong> dodaje drugie kryterium - nieuko≈Ñczone zadania na g√≥rze."
      },
      "en": {
        "title": "Step 20: Sorting tasks by priority",
        "intro": "We'll add a button that will sort our tasks by priority - most important on top!",
        "code": "// In activity_main.xml we add sort button:\n<Button\n    android:id=\"@+id/buttonSort\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Sort by priority\"\n    android:layout_margin=\"8dp\" />\n\n// In MainActivity.kt we add sorting function:\nval buttonSort = findViewById<Button>(R.id.buttonSort)\nbuttonSort.setOnClickListener {\n    taskList.sortWith(compareByDescending<Task> { it.priority }.thenBy { it.isCompleted })\n    adapter.notifyDataSetChanged()\n    Toast.makeText(this, \"List sorted!\", Toast.LENGTH_SHORT).show()\n}",
        "explanation": "<strong>sortWith</strong> sorts the list by given criteria. <strong>compareByDescending</strong> sorts descending (3,2,1). <strong>thenBy</strong> adds second criterion - incomplete tasks on top."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-21",
      "pl": {
        "title": "Krok 21: SharedPreferences - zapisywanie danych",
        "intro": "Nasze zadania znikajƒÖ po zamkniƒôciu aplikacji! Dodamy mo≈ºliwo≈õƒá zapisywania ich w pamiƒôci telefonu.",
        "code": "// W MainActivity.kt dodajemy funkcje do zapisywania:\nimport android.content.SharedPreferences\nimport com.google.gson.Gson\nimport com.google.gson.reflect.TypeToken\n\nclass MainActivity : AppCompatActivity() {\n    private lateinit var sharedPreferences: SharedPreferences\n    private val gson = Gson()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        sharedPreferences = getSharedPreferences(\"TaskPrefs\", Context.MODE_PRIVATE)\n        loadTasks() // ≈Åadujemy zapisane zadania\n    }\n    \n    private fun saveTasks() {\n        val json = gson.toJson(taskList)\n        sharedPreferences.edit().putString(\"tasks\", json).apply()\n    }\n}",
        "explanation": "<strong>SharedPreferences</strong> pozwala zapisywaƒá proste dane na telefonie. <strong>Gson</strong> to biblioteka do konwersji obiekt√≥w na JSON i odwrotnie."
      },
      "en": {
        "title": "Step 21: SharedPreferences - saving data",
        "intro": "Our tasks disappear after closing the app! We'll add the ability to save them in phone's memory.",
        "code": "// In MainActivity.kt we add saving functions:\nimport android.content.SharedPreferences\nimport com.google.gson.Gson\nimport com.google.gson.reflect.TypeToken\n\nclass MainActivity : AppCompatActivity() {\n    private lateinit var sharedPreferences: SharedPreferences\n    private val gson = Gson()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        sharedPreferences = getSharedPreferences(\"TaskPrefs\", Context.MODE_PRIVATE)\n        loadTasks() // Load saved tasks\n    }\n    \n    private fun saveTasks() {\n        val json = gson.toJson(taskList)\n        sharedPreferences.edit().putString(\"tasks\", json).apply()\n    }\n}",
        "explanation": "<strong>SharedPreferences</strong> allows saving simple data on the phone. <strong>Gson</strong> is a library for converting objects to JSON and back."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-22",
      "pl": {
        "title": "Krok 22: Wczytywanie zapisanych zada≈Ñ",
        "intro": "Teraz dodamy funkcjƒô, kt√≥ra wczyta nasze zadania przy starcie aplikacji!",
        "code": "// Dodajemy funkcjƒô ≈Çadowania zada≈Ñ:\nprivate fun loadTasks() {\n    val json = sharedPreferences.getString(\"tasks\", \"\")\n    if (json?.isNotEmpty() == true) {\n        try {\n            val type = object : TypeToken<MutableList<Task>>() {}.type\n            val savedTasks: MutableList<Task> = gson.fromJson(json, type)\n            taskList.clear()\n            taskList.addAll(savedTasks)\n        } catch (e: Exception) {\n            // Je≈õli wystƒÖpi b≈ÇƒÖd, rozpoczynamy z pustƒÖ listƒÖ\n            taskList.clear()\n            addDefaultTasks()\n        }\n    } else {\n        addDefaultTasks()\n    }\n}\n\nprivate fun addDefaultTasks() {\n    taskList.add(Task(\"Witaj w Plannerze!\", false, \"Og√≥lne\", 1))\n    taskList.add(Task(\"Dodaj swoje pierwsze zadanie\", false, \"Og√≥lne\", 2))\n}",
        "explanation": "<strong>TypeToken</strong> pomaga Gson zrozumieƒá, jaki typ danych ma odczytaƒá z JSON. <strong>try-catch</strong> chroni przed b≈Çƒôdami podczas wczytywania."
      },
      "en": {
        "title": "Step 22: Loading saved tasks",
        "intro": "Now we'll add a function that loads our tasks when the app starts!",
        "code": "// We add task loading function:\nprivate fun loadTasks() {\n    val json = sharedPreferences.getString(\"tasks\", \"\")\n    if (json?.isNotEmpty() == true) {\n        try {\n            val type = object : TypeToken<MutableList<Task>>() {}.type\n            val savedTasks: MutableList<Task> = gson.fromJson(json, type)\n            taskList.clear()\n            taskList.addAll(savedTasks)\n        } catch (e: Exception) {\n            // If error occurs, start with empty list\n            taskList.clear()\n            addDefaultTasks()\n        }\n    } else {\n        addDefaultTasks()\n    }\n}\n\nprivate fun addDefaultTasks() {\n    taskList.add(Task(\"Welcome to Planner!\", false, \"General\", 1))\n    taskList.add(Task(\"Add your first task\", false, \"General\", 2))\n}",
        "explanation": "<strong>TypeToken</strong> helps Gson understand what type of data to read from JSON. <strong>try-catch</strong> protects against errors during loading."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-23",
      "pl": {
        "title": "Krok 23: Automatyczne zapisywanie po zmianach",
        "intro": "Teraz sprawimy, ≈ºe zadania bƒôdƒÖ zapisywane automatycznie po ka≈ºdej zmianie!",
        "code": "// Aktualizujemy funkcje, ≈ºeby zapisywa≈Çy dane:\n// W funkcji dodawania zadania:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    if (taskTitle.isNotEmpty()) {\n        val selectedCategory = spinnerCategory.selectedItem.toString()\n        val selectedPriority = seekBarPriority.progress + 1\n        \n        val newTask = Task(taskTitle, false, selectedCategory, selectedPriority)\n        taskList.add(newTask)\n        adapter.notifyDataSetChanged()\n        saveTasks() // Zapisujemy po dodaniu!\n        \n        clearForm()\n        Toast.makeText(this, \"Dodano: $taskTitle\", Toast.LENGTH_SHORT).show()\n    }\n}\n\n// W funkcji oznaczania jako uko≈Ñczone:\nlistView.setOnItemClickListener { _, _, position, _ ->\n    val task = taskList[position]\n    task.isCompleted = !task.isCompleted\n    adapter.notifyDataSetChanged()\n    saveTasks() // Zapisujemy po zmianie!\n    \n    val message = if (task.isCompleted) \"Uko≈Ñczono\" else \"Przywr√≥cono\"\n    Toast.makeText(this, \"$message: ${task.title}\", Toast.LENGTH_SHORT).show()\n}",
        "explanation": "Teraz po ka≈ºdej zmianie (dodanie, uko≈Ñczenie, usuniƒôcie) wywo≈Çujemy <strong>saveTasks()</strong>, wiƒôc dane sƒÖ zawsze aktualne."
      },
      "en": {
        "title": "Step 23: Automatic saving after changes",
        "intro": "Now we'll make tasks save automatically after every change!",
        "code": "// We update functions to save data:\n// In task adding function:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    if (taskTitle.isNotEmpty()) {\n        val selectedCategory = spinnerCategory.selectedItem.toString()\n        val selectedPriority = seekBarPriority.progress + 1\n        \n        val newTask = Task(taskTitle, false, selectedCategory, selectedPriority)\n        taskList.add(newTask)\n        adapter.notifyDataSetChanged()\n        saveTasks() // Save after adding!\n        \n        clearForm()\n        Toast.makeText(this, \"Added: $taskTitle\", Toast.LENGTH_SHORT).show()\n    }\n}\n\n// In completion marking function:\nlistView.setOnItemClickListener { _, _, position, _ ->\n    val task = taskList[position]\n    task.isCompleted = !task.isCompleted\n    adapter.notifyDataSetChanged()\n    saveTasks() // Save after change!\n    \n    val message = if (task.isCompleted) \"Completed\" else \"Restored\"\n    Toast.makeText(this, \"$message: ${task.title}\", Toast.LENGTH_SHORT).show()\n}",
        "explanation": "Now after every change (adding, completing, deleting) we call <strong>saveTasks()</strong>, so data is always current."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    	
	 {
      "id": "step-24",
      "pl": {
        "title": "Krok 24: Filtrowanie zada≈Ñ wed≈Çug kategorii",
        "intro": "Dodamy mo≈ºliwo≈õƒá pokazywania tylko zada≈Ñ z wybranej kategorii!",
        "code": "// Dodajemy przycisk filtrowania w XML:\n<Button\n    android:id=\"@+id/buttonFilter\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Filtruj kategoriƒô\"\n    android:layout_margin=\"8dp\" />\n\n// W MainActivity.kt dodajemy filtrowanie:\nvar currentFilter = \"Wszystkie\"\n\nval buttonFilter = findViewById<Button>(R.id.buttonFilter)\nbuttonFilter.setOnClickListener {\n    showCategoryFilterDialog()\n}\n\nprivate fun showCategoryFilterDialog() {\n    val categories = arrayOf(\"Wszystkie\", \"Szko≈Ça\", \"Dom\", \"Hobby\", \"Sport\", \"Zakupy\")\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Wybierz kategoriƒô\")\n        .setItems(categories) { _, which ->\n            currentFilter = categories[which]\n            filterTasks(currentFilter)\n            Toast.makeText(this, \"Filtr: $currentFilter\", Toast.LENGTH_SHORT).show()\n        }\n        .show()\n}",
        "explanation": "<strong>AlertDialog</strong> z <strong>setItems</strong> tworzy listƒô opcji do wyboru. <strong>currentFilter</strong> przechowuje aktualnie wybrany filtr."
      },
      "en": {
        "title": "Step 24: Filtering tasks by category",
        "intro": "We'll add the ability to show only tasks from selected category!",
        "code": "// Add filter button in XML:\n<Button\n    android:id=\"@+id/buttonFilter\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Filter category\"\n    android:layout_margin=\"8dp\" />\n\n// In MainActivity.kt we add filtering:\nvar currentFilter = \"All\"\n\nval buttonFilter = findViewById<Button>(R.id.buttonFilter)\nbuttonFilter.setOnClickListener {\n    showCategoryFilterDialog()\n}\n\nprivate fun showCategoryFilterDialog() {\n    val categories = arrayOf(\"All\", \"School\", \"Home\", \"Hobby\", \"Sport\", \"Shopping\")\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Choose category\")\n        .setItems(categories) { _, which ->\n            currentFilter = categories[which]\n            filterTasks(currentFilter)\n            Toast.makeText(this, \"Filter: $currentFilter\", Toast.LENGTH_SHORT).show()\n        }\n        .show()\n}",
        "explanation": "<strong>AlertDialog</strong> with <strong>setItems</strong> creates a list of options to choose from. <strong>currentFilter</strong> stores the currently selected filter."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-25",
      "pl": {
        "title": "Krok 25: Implementacja funkcji filtrowania",
        "intro": "Teraz napiszemy funkcjƒô, kt√≥ra faktycznie przefiltruje i wy≈õwietli zadania!",
        "code": "// Dodajemy funkcjƒô filtrowania:\nprivate fun filterTasks(category: String) {\n    val filteredList = if (category == \"Wszystkie\") {\n        taskList.toList() // Wszystkie zadania\n    } else {\n        taskList.filter { it.category == category } // Tylko z wybranej kategorii\n    }\n    \n    // Tworzymy nowy adapter z przefiltrowanƒÖ listƒÖ\n    val filteredAdapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, filteredList)\n    listView.adapter = filteredAdapter\n    \n    // Aktualizujemy tekst przycisku\n    buttonFilter.text = if (category == \"Wszystkie\") {\n        \"Filtruj kategoriƒô\"\n    } else {\n        \"Filtr: $category (${filteredList.size})\"\n    }\n}\n\n// Funkcja do resetowania filtra\nprivate fun resetFilter() {\n    currentFilter = \"Wszystkie\"\n    listView.adapter = adapter // Przywracamy oryginalny adapter\n    buttonFilter.text = \"Filtruj kategoriƒô\"\n}\n\n// Aktualizujemy funkcjƒô dodawania zadania:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    if (taskTitle.isNotEmpty()) {\n        // ... kod dodawania zadania ...\n        \n        // Je≈õli filtr jest aktywny, od≈õwie≈ºamy go\n        if (currentFilter != \"Wszystkie\") {\n            filterTasks(currentFilter)\n        }\n    }\n}",
        "explanation": "<strong>filter</strong> tworzy nowƒÖ listƒô zawierajƒÖcƒÖ tylko elementy spe≈ÇniajƒÖce warunek. Zmieniamy tekst przycisku, ≈ºeby pokazaƒá aktywny filtr i liczbƒô zada≈Ñ."
      },
      "en": {
        "title": "Step 25: Implementing filter function",
        "intro": "Now we'll write a function that actually filters and displays tasks!",
        "code": "// We add filtering function:\nprivate fun filterTasks(category: String) {\n    val filteredList = if (category == \"All\") {\n        taskList.toList() // All tasks\n    } else {\n        taskList.filter { it.category == category } // Only from selected category\n    }\n    \n    // Create new adapter with filtered list\n    val filteredAdapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, filteredList)\n    listView.adapter = filteredAdapter\n    \n    // Update button text\n    buttonFilter.text = if (category == \"All\") {\n        \"Filter category\"\n    } else {\n        \"Filter: $category (${filteredList.size})\"\n    }\n}\n\n// Function to reset filter\nprivate fun resetFilter() {\n    currentFilter = \"All\"\n    listView.adapter = adapter // Restore original adapter\n    buttonFilter.text = \"Filter category\"\n}\n\n// Update task adding function:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    if (taskTitle.isNotEmpty()) {\n        // ... task adding code ...\n        \n        // If filter is active, refresh it\n        if (currentFilter != \"All\") {\n            filterTasks(currentFilter)\n        }\n    }\n}",
        "explanation": "<strong>filter</strong> creates a new list containing only elements that meet the condition. We change button text to show active filter and task count."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-26",
      "pl": {
        "title": "Krok 26: Licznik zada≈Ñ i statystyki",
        "intro": "Dodamy licznik, kt√≥ry poka≈ºe, ile zada≈Ñ mamy uko≈Ñczonych i ile jeszcze do zrobienia!",
        "code": "// W activity_main.xml dodajemy TextView dla statystyk:\n<TextView\n    android:id=\"@+id/textStats\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Zadania: 0 uko≈Ñczonych z 0 og√≥≈Çem\"\n    android:textAlign=\"center\"\n    android:textSize=\"16sp\"\n    android:padding=\"16dp\"\n    android:background=\"#E3F2FD\" />\n\n// W MainActivity.kt dodajemy funkcjƒô aktualizacji statystyk:\nprivate fun updateStats() {\n    val totalTasks = taskList.size\n    val completedTasks = taskList.count { it.isCompleted }\n    val pendingTasks = totalTasks - completedTasks\n    \n    val statsText = \"Zadania: $completedTasks uko≈Ñczonych z $totalTasks og√≥≈Çem ($pendingTasks do zrobienia)\"\n    findViewById<TextView>(R.id.textStats).text = statsText\n    \n    // Zmieniamy kolor w zale≈ºno≈õci od postƒôpu\n    val progressPercent = if (totalTasks > 0) (completedTasks * 100) / totalTasks else 0\n    val backgroundColor = when {\n        progressPercent >= 80 -> Color.parseColor(\"#C8E6C9\") // Zielony - ≈õwietny postƒôp\n        progressPercent >= 50 -> Color.parseColor(\"#FFF9C4\") // ≈ª√≥≈Çty - dobry postƒôp\n        progressPercent > 0 -> Color.parseColor(\"#FFECB3\") // Jasnopomara≈Ñczowy - poczƒÖtek\n        else -> Color.parseColor(\"#FFCDD2\") // Czerwony - brak postƒôpu\n    }\n    findViewById<TextView>(R.id.textStats).setBackgroundColor(backgroundColor)\n}\n\n// Wywo≈Çujemy updateStats() po ka≈ºdej zmianie:\n// - Po dodaniu zadania\n// - Po oznaczeniu jako uko≈Ñczone\n// - Po usuniƒôciu zadania\n// - W onCreate()",
        "explanation": "<strong>count</strong> zlicza elementy spe≈ÇniajƒÖce warunek. Zmieniamy kolor t≈Ça w zale≈ºno≈õci od procentu uko≈Ñczonych zada≈Ñ - to motywuje do dzia≈Çania!"
      },
      "en": {
        "title": "Step 26: Task counter and statistics",
        "intro": "We'll add a counter that shows how many tasks we have completed and how many are still to do!",
        "code": "// In activity_main.xml we add TextView for statistics:\n<TextView\n    android:id=\"@+id/textStats\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Tasks: 0 completed out of 0 total\"\n    android:textAlign=\"center\"\n    android:textSize=\"16sp\"\n    android:padding=\"16dp\"\n    android:background=\"#E3F2FD\" />\n\n// In MainActivity.kt we add stats update function:\nprivate fun updateStats() {\n    val totalTasks = taskList.size\n    val completedTasks = taskList.count { it.isCompleted }\n    val pendingTasks = totalTasks - completedTasks\n    \n    val statsText = \"Tasks: $completedTasks completed out of $totalTasks total ($pendingTasks to do)\"\n    findViewById<TextView>(R.id.textStats).text = statsText\n    \n    // Change color based on progress\n    val progressPercent = if (totalTasks > 0) (completedTasks * 100) / totalTasks else 0\n    val backgroundColor = when {\n        progressPercent >= 80 -> Color.parseColor(\"#C8E6C9\") // Green - great progress\n        progressPercent >= 50 -> Color.parseColor(\"#FFF9C4\") // Yellow - good progress\n        progressPercent > 0 -> Color.parseColor(\"#FFECB3\") // Light orange - beginning\n        else -> Color.parseColor(\"#FFCDD2\") // Red - no progress\n    }\n    findViewById<TextView>(R.id.textStats).setBackgroundColor(backgroundColor)\n}\n\n// We call updateStats() after every change:\n// - After adding task\n// - After marking as completed\n// - After deleting task\n// - In onCreate()",
        "explanation": "<strong>count</strong> counts elements that meet the condition. We change background color based on percentage of completed tasks - this motivates action!"
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-27",
      "pl": {
        "title": "Krok 27: Niestandardowy adapter z lepszym wyglƒÖdem",
        "intro": "Stworzymy w≈Çasny adapter, kt√≥ry nada naszym zadaniom ≈Çadniejszy wyglƒÖd!",
        "code": "// Tworzymy niestandardowy adapter:\nclass TaskAdapter(context: Context, private val tasks: MutableList<Task>) : \n    ArrayAdapter<Task>(context, R.layout.task_item, tasks) {\n    \n    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {\n        val view = convertView ?: LayoutInflater.from(context)\n            .inflate(R.layout.task_item, parent, false)\n        \n        val task = tasks[position]\n        \n        val textTitle = view.findViewById<TextView>(R.id.textTitle)\n        val textCategory = view.findViewById<TextView>(R.id.textCategory)\n        val imageStatus = view.findViewById<ImageView>(R.id.imageStatus)\n        val imagePriority = view.findViewById<ImageView>(R.id.imagePriority)\n        \n        textTitle.text = task.title\n        textCategory.text = task.category\n        \n        // Ustawiamy ikony statusu\n        if (task.isCompleted) {\n            imageStatus.setImageResource(R.drawable.ic_check_circle)\n            textTitle.paintFlags = textTitle.paintFlags or Paint.STRIKE_THRU_TEXT_FLAG\n            textTitle.alpha = 0.6f\n        } else {\n            imageStatus.setImageResource(R.drawable.ic_radio_button_unchecked)\n            textTitle.paintFlags = textTitle.paintFlags and Paint.STRIKE_THRU_TEXT_FLAG.inv()\n            textTitle.alpha = 1.0f\n        }\n        \n        // Ustawiamy ikony priorytetu\n        when (task.priority) {\n            3 -> imagePriority.setImageResource(R.drawable.ic_priority_high)\n            2 -> imagePriority.setImageResource(R.drawable.ic_priority_medium)\n            else -> imagePriority.setImageResource(R.drawable.ic_priority_low)\n        }\n        \n        return view\n    }\n}\n\n// W MainActivity.kt zmieniamy na nowy adapter:\noverride fun onCreate(savedInstanceState: Bundle?) {\n    // ... kod ...\n    \n    val listView = findViewById<ListView>(R.id.listViewTasks)\n    adapter = TaskAdapter(this, taskList) // U≈ºywamy nowego adaptera\n    listView.adapter = adapter\n}",
        "explanation": "Niestandardowy adapter pozwala nam kontrolowaƒá, jak wyglƒÖda ka≈ºdy element listy. <strong>STRIKE_THRU_TEXT_FLAG</strong> przekre≈õla tekst uko≈Ñczonych zada≈Ñ. <strong>alpha</strong> zmienia przezroczysto≈õƒá."
      },
      "en": {
        "title": "Step 27: Custom adapter with better appearance",
        "intro": "We'll create our own adapter that will give our tasks a nicer look!",
        "code": "// We create custom adapter:\nclass TaskAdapter(context: Context, private val tasks: MutableList<Task>) : \n    ArrayAdapter<Task>(context, R.layout.task_item, tasks) {\n    \n    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {\n        val view = convertView ?: LayoutInflater.from(context)\n            .inflate(R.layout.task_item, parent, false)\n        \n        val task = tasks[position]\n        \n        val textTitle = view.findViewById<TextView>(R.id.textTitle)\n        val textCategory = view.findViewById<TextView>(R.id.textCategory)\n        val imageStatus = view.findViewById<ImageView>(R.id.imageStatus)\n        val imagePriority = view.findViewById<ImageView>(R.id.imagePriority)\n        \n        textTitle.text = task.title\n        textCategory.text = task.category\n        \n        // Set status icons\n        if (task.isCompleted) {\n            imageStatus.setImageResource(R.drawable.ic_check_circle)\n            textTitle.paintFlags = textTitle.paintFlags or Paint.STRIKE_THRU_TEXT_FLAG\n            textTitle.alpha = 0.6f\n        } else {\n            imageStatus.setImageResource(R.drawable.ic_radio_button_unchecked)\n            textTitle.paintFlags = textTitle.paintFlags and Paint.STRIKE_THRU_TEXT_FLAG.inv()\n            textTitle.alpha = 1.0f\n        }\n        \n        // Set priority icons\n        when (task.priority) {\n            3 -> imagePriority.setImageResource(R.drawable.ic_priority_high)\n            2 -> imagePriority.setImageResource(R.drawable.ic_priority_medium)\n            else -> imagePriority.setImageResource(R.drawable.ic_priority_low)\n        }\n        \n        return view\n    }\n}\n\n// In MainActivity.kt we change to new adapter:\noverride fun onCreate(savedInstanceState: Bundle?) {\n    // ... code ...\n    \n    val listView = findViewById<ListView>(R.id.listViewTasks)\n    adapter = TaskAdapter(this, taskList) // Use new adapter\n    listView.adapter = adapter\n}",
        "explanation": "Custom adapter allows us to control how each list item looks. <strong>STRIKE_THRU_TEXT_FLAG</strong> strikes through text of completed tasks. <strong>alpha</strong> changes transparency."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-28",
      "pl": {
        "title": "Krok 28: Layout dla elementu zadania",
        "intro": "Stworzymy piƒôkny layout dla pojedynczego zadania z ikonami i kolorami!",
        "code": "<!-- Tworzymy plik task_item.xml w folderze layout: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\"\n    android:padding=\"16dp\"\n    android:background=\"?android:attr/selectableItemBackground\">\n\n    <ImageView\n        android:id=\"@+id/imageStatus\"\n        android:layout_width=\"24dp\"\n        android:layout_height=\"24dp\"\n        android:layout_marginEnd=\"12dp\"\n        android:src=\"@drawable/ic_radio_button_unchecked\"\n        android:layout_gravity=\"center_vertical\" />\n\n    <LinearLayout\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:orientation=\"vertical\">\n\n        <TextView\n            android:id=\"@+id/textTitle\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Tytu≈Ç zadania\"\n            android:textSize=\"16sp\"\n            android:textStyle=\"bold\"\n            android:textColor=\"#212121\" />\n\n        <TextView\n            android:id=\"@+id/textCategory\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Kategoria\"\n            android:textSize=\"12sp\"\n            android:textColor=\"#666666\"\n            android:layout_marginTop=\"4dp\" />\n    </LinearLayout>\n\n    <ImageView\n        android:id=\"@+id/imagePriority\"\n        android:layout_width=\"20dp\"\n        android:layout_height=\"20dp\"\n        android:src=\"@drawable/ic_priority_low\"\n        android:layout_gravity=\"center_vertical\"\n        android:layout_marginStart=\"8dp\" />\n</LinearLayout>",
        "explanation": "Ten layout tworzy ≈Çadny element listy z ikonƒÖ statusu, tytu≈Çem, kategoriƒÖ i priorytetem. <strong>layout_weight=\"1\"</strong> sprawia, ≈ºe ≈õrodkowa czƒô≈õƒá zajmuje ca≈ÇƒÖ dostƒôpnƒÖ przestrze≈Ñ. <strong>selectableItemBackground</strong> dodaje efekt dotkniƒôcia."
      },
      "en": {
        "title": "Step 28: Layout for task item",
        "intro": "We'll create a beautiful layout for individual task with icons and colors!",
        "code": "<!-- We create task_item.xml file in layout folder: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\"\n    android:padding=\"16dp\"\n    android:background=\"?android:attr/selectableItemBackground\">\n\n    <ImageView\n        android:id=\"@+id/imageStatus\"\n        android:layout_width=\"24dp\"\n        android:layout_height=\"24dp\"\n        android:layout_marginEnd=\"12dp\"\n        android:src=\"@drawable/ic_radio_button_unchecked\"\n        android:layout_gravity=\"center_vertical\" />\n\n    <LinearLayout\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:orientation=\"vertical\">\n\n        <TextView\n            android:id=\"@+id/textTitle\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Task title\"\n            android:textSize=\"16sp\"\n            android:textStyle=\"bold\"\n            android:textColor=\"#212121\" />\n\n        <TextView\n            android:id=\"@+id/textCategory\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Category\"\n            android:textSize=\"12sp\"\n            android:textColor=\"#666666\"\n            android:layout_marginTop=\"4dp\" />\n    </LinearLayout>\n\n    <ImageView\n        android:id=\"@+id/imagePriority\"\n        android:layout_width=\"20dp\"\n        android:layout_height=\"20dp\"\n        android:src=\"@drawable/ic_priority_low\"\n        android:layout_gravity=\"center_vertical\"\n        android:layout_marginStart=\"8dp\" />\n</LinearLayout>",
        "explanation": "This layout creates a nice list item with status icon, title, category and priority. <strong>layout_weight=\"1\"</strong> makes the middle part take all available space. <strong>selectableItemBackground</strong> adds touch effect."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-29",
      "pl": {
        "title": "Krok 29: Animacje i przej≈õcia",
        "intro": "Dodamy p≈Çynne animacje, kt√≥re sprawiƒÖ, ≈ºe nasza aplikacja bƒôdzie wyglƒÖdaƒá profesjonalnie!",
        "code": "// W MainActivity.kt dodajemy animacje:\nimport android.view.animation.AnimationUtils\nimport android.view.animation.Animation\n\nprivate fun animateTaskCompletion(view: View, task: Task) {\n    val animation = if (task.isCompleted) {\n        AnimationUtils.loadAnimation(this, R.anim.task_complete)\n    } else {\n        AnimationUtils.loadAnimation(this, R.anim.task_restore)\n    }\n    \n    view.startAnimation(animation)\n}\n\n// Modyfikujemy klikniƒôcie zadania:\nlistView.setOnItemClickListener { _, view, position, _ ->\n    val task = taskList[position]\n    task.isCompleted = !task.isCompleted\n    \n    // Dodajemy animacjƒô\n    animateTaskCompletion(view, task)\n    \n    // Op√≥≈∫niamy aktualizacjƒô adaptera, ≈ºeby animacja siƒô sko≈Ñczy≈Ça\n    Handler(Looper.getMainLooper()).postDelayed({\n        adapter.notifyDataSetChanged()\n        saveTasks()\n        updateStats()\n    }, 200)\n    \n    val message = if (task.isCompleted) \"Uko≈Ñczono\" else \"Przywr√≥cono\"\n    Toast.makeText(this, \"$message: ${task.title}\", Toast.LENGTH_SHORT).show()\n}\n\n// Dodajemy animacjƒô fade-in dla nowo dodanych zada≈Ñ:\nprivate fun animateNewTask(view: View) {\n    view.alpha = 0f\n    view.animate()\n        .alpha(1f)\n        .setDuration(300)\n        .start()\n}\n\n// Animacja dla usuniƒôcia zadania:\nprivate fun animateTaskRemoval(view: View, onComplete: () -> Unit) {\n    view.animate()\n        .alpha(0f)\n        .translationX(view.width.toFloat())\n        .setDuration(250)\n        .withEndAction(onComplete)\n        .start()\n}",
        "explanation": "<strong>AnimationUtils</strong> ≈Çaduje animacje z plik√≥w XML. <strong>Handler.postDelayed</strong> op√≥≈∫nia wykonanie kodu, ≈ºeby animacja mia≈Ça czas siƒô wykonaƒá. <strong>animate()</strong> tworzy p≈Çynne animacje w≈Ça≈õciwo≈õci widoku."
      },
      "en": {
        "title": "Step 29: Animations and transitions",
        "intro": "We'll add smooth animations that will make our app look professional!",
        "code": "// In MainActivity.kt we add animations:\nimport android.view.animation.AnimationUtils\nimport android.view.animation.Animation\n\nprivate fun animateTaskCompletion(view: View, task: Task) {\n    val animation = if (task.isCompleted) {\n        AnimationUtils.loadAnimation(this, R.anim.task_complete)\n    } else {\n        AnimationUtils.loadAnimation(this, R.anim.task_restore)\n    }\n    \n    view.startAnimation(animation)\n}\n\n// We modify task click:\nlistView.setOnItemClickListener { _, view, position, _ ->\n    val task = taskList[position]\n    task.isCompleted = !task.isCompleted\n    \n    // Add animation\n    animateTaskCompletion(view, task)\n    \n    // Delay adapter update so animation can finish\n    Handler(Looper.getMainLooper()).postDelayed({\n        adapter.notifyDataSetChanged()\n        saveTasks()\n        updateStats()\n    }, 200)\n    \n    val message = if (task.isCompleted) \"Completed\" else \"Restored\"\n    Toast.makeText(this, \"$message: ${task.title}\", Toast.LENGTH_SHORT).show()\n}\n\n// Add fade-in animation for newly added tasks:\nprivate fun animateNewTask(view: View) {\n    view.alpha = 0f\n    view.animate()\n        .alpha(1f)\n        .setDuration(300)\n        .start()\n}\n\n// Animation for task removal:\nprivate fun animateTaskRemoval(view: View, onComplete: () -> Unit) {\n    view.animate()\n        .alpha(0f)\n        .translationX(view.width.toFloat())\n        .setDuration(250)\n        .withEndAction(onComplete)\n        .start()\n}",
        "explanation": "<strong>AnimationUtils</strong> loads animations from XML files. <strong>Handler.postDelayed</strong> delays code execution so animation has time to complete. <strong>animate()</strong> creates smooth animations of view properties."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-30",
      "pl": {
        "title": "Krok 30: Pliki animacji XML",
        "intro": "Stworzymy pliki XML z definicjami animacji dla naszych zada≈Ñ!",
        "code": "<!-- Tworzymy folder anim w res i dodajemy task_complete.xml: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <scale\n        android:duration=\"300\"\n        android:fromAlpha=\"0.0\"\n        android:toAlpha=\"1.0\" />\n    <scale\n        android:duration=\"300\"\n        android:fromXScale=\"0.8\"\n        android:fromYScale=\"0.8\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"1.0\"\n        android:toYScale=\"1.0\" />\n</set>\n\n<!-- task_remove.xml (dla usuwanych zada≈Ñ): -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <translate\n        android:duration=\"250\"\n        android:fromXDelta=\"0\"\n        android:toXDelta=\"100%\" />\n    <alpha\n        android:duration=\"250\"\n        android:fromAlpha=\"1.0\"\n        android:toAlpha=\"0.0\" />\n    <scale\n        android:duration=\"250\"\n        android:fromXScale=\"1.0\"\n        android:fromYScale=\"1.0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"0.8\"\n        android:toYScale=\"0.8\" />\n</set>",
        "explanation": "<strong>scale</strong> zmienia rozmiar elementu, <strong>alpha</strong> zmienia przezroczysto≈õƒá, <strong>translate</strong> przesuwa element. <strong>startOffset</strong> op√≥≈∫nia start animacji. Te animacje dajƒÖ przyjemny efekt wizualny i sprawiajƒÖ, ≈ºe aplikacja czuje siƒô ≈ºywa!"
      },
      "en": {
        "title": "Step 30: Animation XML files",
        "intro": "We'll create XML files with animation definitions for our tasks!",
        "code": "<!-- We create anim folder in res and add task_complete.xml: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <scale\n        android:duration=\"200\"\n        android:fromXScale=\"1.0\"\n        android:fromYScale=\"1.0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"1.1\"\n        android:toYScale=\"1.1\" />\n    <scale\n        android:duration=\"200\"\n        android:fromXScale=\"1.1\"\n        android:fromYScale=\"1.1\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:startOffset=\"200\"\n        android:toXScale=\"1.0\"\n        android:toYScale=\"1.0\" />\n    <alpha\n        android:duration=\"100\"\n        android:fromAlpha=\"1.0\"\n        android:startOffset=\"200\"\n        android:toAlpha=\"0.7\" />\n</set>\n\n<!-- task_restore.xml: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <alpha\n        android:duration=\"150\"\n        android:fromAlpha=\"0.7\"\n        android:toAlpha=\"1.0\" />\n    <scale\n        android:duration=\"150\"\n        android:fromXScale=\"0.95\"\n        android:fromYScale=\"0.95\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"1.0\"\n        android:toYScale=\"1.0\" />\n</set>\n\n<!-- task_add.xml (for new tasks): -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <translate\n        android:duration=\"300\"\n        android:fromYDelta=\"50\"\n        android:toYDelta=\"0\" />\n    <alpha\n        android:duration=\"300\"\n        android:fromAlpha=\"0.0\"\n        android:toAlpha=\"1.0\" />\n    <scale\n        android:duration=\"300\"\n        android:fromXScale=\"0.8\"\n        android:fromYScale=\"0.8\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"1.0\"\n        android:toYScale=\"1.0\" />\n</set>\n\n<!-- task_remove.xml (for removed tasks): -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <translate\n        android:duration=\"250\"\n        android:fromXDelta=\"0\"\n        android:toXDelta=\"100%\" />\n    <alpha\n        android:duration=\"250\"\n        android:fromAlpha=\"1.0\"\n        android:toAlpha=\"0.0\" />\n    <scale\n        android:duration=\"250\"\n        android:fromXScale=\"1.0\"\n        android:fromYScale=\"1.0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"0.8\"\n        android:toYScale=\"0.8\" />\n</set>",
        "explanation": "<strong>scale</strong> changes element size, <strong>alpha</strong> changes transparency, <strong>translate</strong> moves element. <strong>startOffset</strong> delays animation start. These animations give nice visual effect and make the app feel alive!"
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
	
	
	{
      "id": "step-31",
      "pl": {
        "title": "Krok 31: Dodawanie dat do zada≈Ñ",
        "intro": "Teraz nasze zadania bƒôdƒÖ mia≈Çy terminy! Dodamy mo≈ºliwo≈õƒá ustawiania daty wykonania zadania.",
        "code": "// Aktualizujemy klasƒô Task o datƒô:\nimport java.util.Date\nimport java.text.SimpleDateFormat\nimport java.util.Locale\n\ndata class Task(\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"Og√≥lne\",\n    val priority: Int = 1,\n    var dueDate: Date? = null // Nowe pole na datƒô\n) {\n    override fun toString(): String {\n        val status = if (isCompleted) \"‚úì\" else \"‚óã\"\n        val priorityIcon = when (priority) {\n            3 -> \"üî¥\"\n            2 -> \"üü°\"\n            else -> \"üü¢\"\n        }\n        \n        val dateFormat = SimpleDateFormat(\"dd.MM\", Locale.getDefault())\n        val dateText = dueDate?.let { \" (${dateFormat.format(it)})\" } ?: \"\"\n        \n        return \"$status $priorityIcon $title$dateText [$category]\"\n    }\n    \n    fun isOverdue(): Boolean {\n        return dueDate?.let { it.before(Date()) && !isCompleted } ?: false\n    }\n}",
        "explanation": "<strong>Date?</strong> oznacza, ≈ºe data mo≈ºe byƒá null (opcjonalna). <strong>SimpleDateFormat</strong> formatuje datƒô do czytelnej postaci. <strong>isOverdue()</strong> sprawdza, czy zadanie jest przeterminowane."
      },
      "en": {
        "title": "Step 31: Adding dates to tasks",
        "intro": "Now our tasks will have deadlines! We'll add the ability to set task execution dates.",
        "code": "// We update Task class with date:\nimport java.util.Date\nimport java.text.SimpleDateFormat\nimport java.util.Locale\n\ndata class Task(\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"General\",\n    val priority: Int = 1,\n    var dueDate: Date? = null // New field for date\n) {\n    override fun toString(): String {\n        val status = if (isCompleted) \"‚úì\" else \"‚óã\"\n        val priorityIcon = when (priority) {\n            3 -> \"üî¥\"\n            2 -> \"üü°\"\n            else -> \"üü¢\"\n        }\n        \n        val dateFormat = SimpleDateFormat(\"dd.MM\", Locale.getDefault())\n        val dateText = dueDate?.let { \" (${dateFormat.format(it)})\" } ?: \"\"\n        \n        return \"$status $priorityIcon $title$dateText [$category]\"\n    }\n    \n    fun isOverdue(): Boolean {\n        return dueDate?.let { it.before(Date()) && !isCompleted } ?: false\n    }\n}",
        "explanation": "<strong>Date?</strong> means the date can be null (optional). <strong>SimpleDateFormat</strong> formats date to readable form. <strong>isOverdue()</strong> checks if task is overdue."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-32",
      "pl": {
        "title": "Krok 32: DatePicker do wyboru daty",
        "intro": "Dodamy kalendarz, z kt√≥rego u≈ºytkownik bƒôdzie m√≥g≈Ç wybraƒá datƒô dla zadania!",
        "code": "// W activity_main.xml dodajemy przycisk daty:\n<Button\n    android:id=\"@+id/buttonDate\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Wybierz datƒô (opcjonalnie)\"\n    android:layout_margin=\"16dp\"\n    android:drawableStart=\"@drawable/ic_calendar\"\n    android:paddingStart=\"16dp\" />\n\n// W MainActivity.kt dodajemy obs≈Çugƒô daty:\nvar selectedDate: Date? = null\n\nval buttonDate = findViewById<Button>(R.id.buttonDate)\nbuttonDate.setOnClickListener {\n    showDatePicker()\n}\n\nprivate fun showDatePicker() {\n    val calendar = Calendar.getInstance()\n    val year = calendar.get(Calendar.YEAR)\n    val month = calendar.get(Calendar.MONTH)\n    val day = calendar.get(Calendar.DAY_OF_MONTH)\n    \n    DatePickerDialog(this, { _, selectedYear, selectedMonth, selectedDay ->\n        calendar.set(selectedYear, selectedMonth, selectedDay)\n        selectedDate = calendar.time\n        updateDateButton()\n    }, year, month, day).show()\n}",
        "explanation": "<strong>DatePickerDialog</strong> pokazuje kalendarz do wyboru daty. <strong>Calendar</strong> pomaga w pracy z datami. Lambda funkcja wykonuje siƒô po wybraniu daty."
      },
      "en": {
        "title": "Step 32: DatePicker for date selection",
        "intro": "We'll add a calendar from which the user can choose a date for the task!",
        "code": "// In activity_main.xml we add date button:\n<Button\n    android:id=\"@+id/buttonDate\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Choose date (optional)\"\n    android:layout_margin=\"16dp\"\n    android:drawableStart=\"@drawable/ic_calendar\"\n    android:paddingStart=\"16dp\" />\n\n// In MainActivity.kt we add date handling:\nvar selectedDate: Date? = null\n\nval buttonDate = findViewById<Button>(R.id.buttonDate)\nbuttonDate.setOnClickListener {\n    showDatePicker()\n}\n\nprivate fun showDatePicker() {\n    val calendar = Calendar.getInstance()\n    val year = calendar.get(Calendar.YEAR)\n    val month = calendar.get(Calendar.MONTH)\n    val day = calendar.get(Calendar.DAY_OF_MONTH)\n    \n    DatePickerDialog(this, { _, selectedYear, selectedMonth, selectedDay ->\n        calendar.set(selectedYear, selectedMonth, selectedDay)\n        selectedDate = calendar.time\n        updateDateButton()\n    }, year, month, day).show()\n}",
        "explanation": "<strong>DatePickerDialog</strong> shows calendar for date selection. <strong>Calendar</strong> helps working with dates. Lambda function executes after date selection."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-33",
      "pl": {
        "title": "Krok 33: Aktualizacja przycisku daty",
        "intro": "Sprawimy, ≈ºe przycisk pok≈ºe wybranƒÖ datƒô i bƒôdzie mo≈ºna jƒÖ wyczy≈õciƒá!",
        "code": "// Dodajemy funkcjƒô aktualizacji przycisku:\nprivate fun updateDateButton() {\n    val buttonDate = findViewById<Button>(R.id.buttonDate)\n    \n    if (selectedDate != null) {\n        val dateFormat = SimpleDateFormat(\"dd.MM.yyyy\", Locale.getDefault())\n        val formattedDate = dateFormat.format(selectedDate!!)\n        buttonDate.text = \"üìÖ $formattedDate\"\n        buttonDate.setBackgroundColor(Color.parseColor(\"#E8F5E8\"))\n    } else {\n        buttonDate.text = \"Wybierz datƒô (opcjonalnie)\"\n        buttonDate.setBackgroundColor(Color.parseColor(\"#F5F5F5\"))\n    }\n}\n\n// Dodajemy d≈Çugie klikniƒôcie do czyszczenia daty:\nbuttonDate.setOnLongClickListener {\n    selectedDate = null\n    updateDateButton()\n    Toast.makeText(this, \"Data wyczyszczona\", Toast.LENGTH_SHORT).show()\n    true\n}\n\n// Aktualizujemy dodawanie zadania:\nval newTask = Task(\n    title = taskTitle,\n    isCompleted = false,\n    category = selectedCategory,\n    priority = selectedPriority,\n    dueDate = selectedDate\n)",
        "explanation": "<strong>setOnLongClickListener</strong> reaguje na d≈Çugie przytrzymanie. Zmieniamy kolor i tekst przycisku w zale≈ºno≈õci od tego, czy data jest wybrana."
      },
      "en": {
        "title": "Step 33: Updating date button",
        "intro": "We'll make the button show the selected date and allow clearing it!",
        "code": "// We add button update function:\nprivate fun updateDateButton() {\n    val buttonDate = findViewById<Button>(R.id.buttonDate)\n    \n    if (selectedDate != null) {\n        val dateFormat = SimpleDateFormat(\"dd.MM.yyyy\", Locale.getDefault())\n        val formattedDate = dateFormat.format(selectedDate!!)\n        buttonDate.text = \"üìÖ $formattedDate\"\n        buttonDate.setBackgroundColor(Color.parseColor(\"#E8F5E8\"))\n    } else {\n        buttonDate.text = \"Choose date (optional)\"\n        buttonDate.setBackgroundColor(Color.parseColor(\"#F5F5F5\"))\n    }\n}\n\n// Add long click to clear date:\nbuttonDate.setOnLongClickListener {\n    selectedDate = null\n    updateDateButton()\n    Toast.makeText(this, \"Date cleared\", Toast.LENGTH_SHORT).show()\n    true\n}\n\n// Update task adding:\nval newTask = Task(\n    title = taskTitle,\n    isCompleted = false,\n    category = selectedCategory,\n    priority = selectedPriority,\n    dueDate = selectedDate\n)",
        "explanation": "<strong>setOnLongClickListener</strong> responds to long press. We change button color and text depending on whether date is selected."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-34",
      "pl": {
        "title": "Krok 34: Oznaczanie przeterminowanych zada≈Ñ",
        "intro": "Zadania po terminie bƒôdƒÖ wyr√≥≈ºnione czerwonym kolorem, ≈ºeby od razu by≈Ço widaƒá, co wymaga uwagi!",
        "code": "// W TaskAdapter dodajemy kolorowanie przeterminowanych zada≈Ñ:\noverride fun getView(position: Int, convertView: View?, parent: ViewGroup): View {\n    val view = convertView ?: LayoutInflater.from(context)\n        .inflate(R.layout.task_item, parent, false)\n    \n    val task = tasks[position]\n    \n    val textTitle = view.findViewById<TextView>(R.id.textTitle)\n    val textCategory = view.findViewById<TextView>(R.id.textCategory)\n    val textDate = view.findViewById<TextView>(R.id.textDate)\n    val imageStatus = view.findViewById<ImageView>(R.id.imageStatus)\n    \n    textTitle.text = task.title\n    textCategory.text = task.category\n    \n    // Wy≈õwietlamy datƒô je≈õli jest ustawiona\n    if (task.dueDate != null) {\n        val dateFormat = SimpleDateFormat(\"dd.MM.yyyy\", Locale.getDefault())\n        textDate.text = \"üìÖ ${dateFormat.format(task.dueDate!!)}\"\n        textDate.visibility = View.VISIBLE\n        \n        // Kolorujemy przeterminowane zadania\n        if (task.isOverdue()) {\n            view.setBackgroundColor(Color.parseColor(\"#FFEBEE\")) // Jasny czerwony\n            textTitle.setTextColor(Color.parseColor(\"#D32F2F\")) // Ciemny czerwony\n            textDate.setTextColor(Color.parseColor(\"#D32F2F\"))\n        } else {\n            view.setBackgroundColor(Color.TRANSPARENT)\n            textTitle.setTextColor(Color.parseColor(\"#212121\"))\n            textDate.setTextColor(Color.parseColor(\"#666666\"))\n        }\n    } else {\n        textDate.visibility = View.GONE\n        view.setBackgroundColor(Color.TRANSPARENT)\n        textTitle.setTextColor(Color.parseColor(\"#212121\"))\n    }\n    \n    return view\n}",
        "explanation": "Sprawdzamy czy zadanie jest przeterminowane metodƒÖ <strong>isOverdue()</strong> i zmieniamy kolory t≈Ça i tekstu. <strong>View.GONE</strong> ukrywa element gdy nie ma daty."
      },
      "en": {
        "title": "Step 34: Marking overdue tasks",
        "intro": "Overdue tasks will be highlighted in red so you can immediately see what needs attention!",
        "code": "// In TaskAdapter we add coloring of overdue tasks:\noverride fun getView(position: Int, convertView: View?, parent: ViewGroup): View {\n    val view = convertView ?: LayoutInflater.from(context)\n        .inflate(R.layout.task_item, parent, false)\n    \n    val task = tasks[position]\n    \n    val textTitle = view.findViewById<TextView>(R.id.textTitle)\n    val textCategory = view.findViewById<TextView>(R.id.textCategory)\n    val textDate = view.findViewById<TextView>(R.id.textDate)\n    val imageStatus = view.findViewById<ImageView>(R.id.imageStatus)\n    \n    textTitle.text = task.title\n    textCategory.text = task.category\n    \n    // Display date if set\n    if (task.dueDate != null) {\n        val dateFormat = SimpleDateFormat(\"dd.MM.yyyy\", Locale.getDefault())\n        textDate.text = \"üìÖ ${dateFormat.format(task.dueDate!!)}\"\n        textDate.visibility = View.VISIBLE\n        \n        // Color overdue tasks\n        if (task.isOverdue()) {\n            view.setBackgroundColor(Color.parseColor(\"#FFEBEE\")) // Light red\n            textTitle.setTextColor(Color.parseColor(\"#D32F2F\")) // Dark red\n            textDate.setTextColor(Color.parseColor(\"#D32F2F\"))\n        } else {\n            view.setBackgroundColor(Color.TRANSPARENT)\n            textTitle.setTextColor(Color.parseColor(\"#212121\"))\n            textDate.setTextColor(Color.parseColor(\"#666666\"))\n        }\n    } else {\n        textDate.visibility = View.GONE\n        view.setBackgroundColor(Color.TRANSPARENT)\n        textTitle.setTextColor(Color.parseColor(\"#212121\"))\n    }\n    \n    return view\n}",
        "explanation": "We check if task is overdue using <strong>isOverdue()</strong> method and change background and text colors. <strong>View.GONE</strong> hides element when there's no date."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-35",
      "pl": {
        "title": "Krok 35: Powiadomienia - podstawy",
        "intro": "Dodamy powiadomienia, kt√≥re przypomnƒÖ u≈ºytkownikowi o wa≈ºnych zadaniach!",
        "code": "// Dodajemy potrzebne importy:\nimport android.app.NotificationChannel\nimport android.app.NotificationManager\nimport android.app.PendingIntent\nimport android.content.Context\nimport android.content.Intent\nimport androidx.core.app.NotificationCompat\nimport android.os.Build\n\n// W MainActivity dodajemy funkcjƒô tworzenia kana≈Çu powiadomie≈Ñ:\nprivate fun createNotificationChannel() {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        val name = \"Przypomnienia o zadaniach\"\n        val descriptionText = \"Powiadomienia o wa≈ºnych zadaniach\"\n        val importance = NotificationManager.IMPORTANCE_DEFAULT\n        val channel = NotificationChannel(\"TASK_CHANNEL\", name, importance).apply {\n            description = descriptionText\n        }\n        \n        val notificationManager: NotificationManager =\n            getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n        notificationManager.createNotificationChannel(channel)\n    }\n}\n\n// Wywo≈Çujemy w onCreate():\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // ... reszta kodu ...\n    createNotificationChannel()\n}",
        "explanation": "<strong>NotificationChannel</strong> to wymagany kana≈Ç dla powiadomie≈Ñ w nowszych wersjach Android. <strong>IMPORTANCE_DEFAULT</strong> ustawia normalny poziom wa≈ºno≈õci powiadomie≈Ñ."
      },
      "en": {
        "title": "Step 35: Notifications - basics",
        "intro": "We'll add notifications that will remind the user about important tasks!",
        "code": "// We add necessary imports:\nimport android.app.NotificationChannel\nimport android.app.NotificationManager\nimport android.app.PendingIntent\nimport android.content.Context\nimport android.content.Intent\nimport androidx.core.app.NotificationCompat\nimport android.os.Build\n\n// In MainActivity we add notification channel creation function:\nprivate fun createNotificationChannel() {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        val name = \"Task reminders\"\n        val descriptionText = \"Notifications about important tasks\"\n        val importance = NotificationManager.IMPORTANCE_DEFAULT\n        val channel = NotificationChannel(\"TASK_CHANNEL\", name, importance).apply {\n            description = descriptionText\n        }\n        \n        val notificationManager: NotificationManager =\n            getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n        notificationManager.createNotificationChannel(channel)\n    }\n}\n\n// We call in onCreate():\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    // ... rest of code ...\n    createNotificationChannel()\n}",
        "explanation": "<strong>NotificationChannel</strong> is a required channel for notifications in newer Android versions. <strong>IMPORTANCE_DEFAULT</strong> sets normal importance level for notifications."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-36",
      "pl": {
        "title": "Krok 36: Wysy≈Çanie powiadomie≈Ñ",
        "intro": "Teraz stworzymy funkcjƒô, kt√≥ra bƒôdzie wysy≈Çaƒá powiadomienia o wa≈ºnych zadaniach!",
        "code": "// Dodajemy funkcjƒô wysy≈Çania powiadomienia:\nprivate fun sendTaskNotification(task: Task) {\n    val intent = Intent(this, MainActivity::class.java).apply {\n        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK\n    }\n    val pendingIntent: PendingIntent = PendingIntent.getActivity(\n        this, 0, intent, PendingIntent.FLAG_IMMUTABLE\n    )\n    \n    val notification = NotificationCompat.Builder(this, \"TASK_CHANNEL\")\n        .setSmallIcon(R.drawable.ic_notification)\n        .setContentTitle(\"Przypomnienie o zadaniu!\")\n        .setContentText(\"${task.title} - ${task.category}\")\n        .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n        .setContentIntent(pendingIntent)\n        .setAutoCancel(true) // Usuwa powiadomienie po klikniƒôciu\n        .build()\n    \n    val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n    notificationManager.notify(task.hashCode(), notification)\n}\n\n// Dodajemy przycisk do testowania powiadomie≈Ñ:\nval buttonNotify = findViewById<Button>(R.id.buttonNotify)\nbuttonNotify.setOnClickListener {\n    val highPriorityTasks = taskList.filter { it.priority == 3 && !it.isCompleted }\n    if (highPriorityTasks.isNotEmpty()) {\n        sendTaskNotification(highPriorityTasks.first())\n        Toast.makeText(this, \"Wys≈Çano powiadomienie!\", Toast.LENGTH_SHORT).show()\n    } else {\n        Toast.makeText(this, \"Brak zada≈Ñ o wysokim priorytecie\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>PendingIntent</strong> pozwala powiadomienia otworzyƒá aplikacjƒô po klikniƒôciu. <strong>setAutoCancel</strong> automatycznie usuwa powiadomienie. <strong>hashCode()</strong> daje unikalny ID powiadomienia."
      },
      "en": {
        "title": "Step 36: Sending notifications",
        "intro": "Now we'll create a function that will send notifications about important tasks!",
        "code": "// We add notification sending function:\nprivate fun sendTaskNotification(task: Task) {\n    val intent = Intent(this, MainActivity::class.java).apply {\n        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK\n    }\n    val pendingIntent: PendingIntent = PendingIntent.getActivity(\n        this, 0, intent, PendingIntent.FLAG_IMMUTABLE\n    )\n    \n    val notification = NotificationCompat.Builder(this, \"TASK_CHANNEL\")\n        .setSmallIcon(R.drawable.ic_notification)\n        .setContentTitle(\"Task reminder!\")\n        .setContentText(\"${task.title} - ${task.category}\")\n        .setPriority(NotificationCompat.PRIORITY_DEFAULT)\n        .setContentIntent(pendingIntent)\n        .setAutoCancel(true) // Removes notification after click\n        .build()\n    \n    val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n    notificationManager.notify(task.hashCode(), notification)\n}\n\n// Add button to test notifications:\nval buttonNotify = findViewById<Button>(R.id.buttonNotify)\nbuttonNotify.setOnClickListener {\n    val highPriorityTasks = taskList.filter { it.priority == 3 && !it.isCompleted }\n    if (highPriorityTasks.isNotEmpty()) {\n        sendTaskNotification(highPriorityTasks.first())\n        Toast.makeText(this, \"Notification sent!\", Toast.LENGTH_SHORT).show()\n    } else {\n        Toast.makeText(this, \"No high priority tasks\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "<strong>PendingIntent</strong> allows notifications to open the app when clicked. <strong>setAutoCancel</strong> automatically removes notification. <strong>hashCode()</strong> gives unique notification ID."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-37",
      "pl": {
        "title": "Krok 37: D≈∫wiƒôki i wibracje",
        "intro": "Dodamy d≈∫wiƒôki i wibracje, kt√≥re sprawiƒÖ, ≈ºe aplikacja bƒôdzie bardziej interaktywna!",
        "code": "// Dodajemy importy:\nimport android.media.MediaPlayer\nimport android.os.Vibrator\nimport android.os.VibrationEffect\nimport android.content.Context\n\nclass MainActivity : AppCompatActivity() {\n    private var mediaPlayer: MediaPlayer? = null\n    private lateinit var vibrator: Vibrator\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // ... reszta kodu ...\n        \n        vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator\n        setupSounds()\n    }\n    \n    private fun setupSounds() {\n        // Przygotowujemy d≈∫wiƒôk uko≈Ñczenia zadania\n        mediaPlayer = MediaPlayer.create(this, R.raw.task_complete_sound)\n    }\n    \n    private fun playTaskCompleteSound() {\n        try {\n            mediaPlayer?.start()\n        } catch (e: Exception) {\n            // Je≈õli nie ma pliku d≈∫wiƒôkowego, ignorujemy b≈ÇƒÖd\n        }\n    }\n    \n    private fun vibratePhone(duration: Long = 100) {\n        if (vibrator.hasVibrator()) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                vibrator.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))\n            } else {\n                vibrator.vibrate(duration)\n            }\n        }\n    }\n}",
        "explanation": "<strong>MediaPlayer</strong> odtwarza d≈∫wiƒôki. <strong>Vibrator</strong> kontroluje wibracje telefonu. <strong>hasVibrator()</strong> sprawdza, czy urzƒÖdzenie ma silnik wibracji."
      },
      "en": {
        "title": "Step 37: Sounds and vibrations",
        "intro": "We'll add sounds and vibrations that will make the app more interactive!",
        "code": "// We add imports:\nimport android.media.MediaPlayer\nimport android.os.Vibrator\nimport android.os.VibrationEffect\nimport android.content.Context\n\nclass MainActivity : AppCompatActivity() {\n    private var mediaPlayer: MediaPlayer? = null\n    private lateinit var vibrator: Vibrator\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // ... rest of code ...\n        \n        vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator\n        setupSounds()\n    }\n    \n    private fun setupSounds() {\n        // Prepare task completion sound\n        mediaPlayer = MediaPlayer.create(this, R.raw.task_complete_sound)\n    }\n    \n    private fun playTaskCompleteSound() {\n        try {\n            mediaPlayer?.start()\n        } catch (e: Exception) {\n            // If no sound file, ignore error\n        }\n    }\n    \n    private fun vibratePhone(duration: Long = 100) {\n        if (vibrator.hasVibrator()) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n                vibrator.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))\n            } else {\n                vibrator.vibrate(duration)\n            }\n        }\n    }\n}",
        "explanation": "<strong>MediaPlayer</strong> plays sounds. <strong>Vibrator</strong> controls phone vibrations. <strong>hasVibrator()</strong> checks if device has vibration motor."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
	 {
      "id": "step-38",
      "pl": {
        "title": "Krok 38: Integracja d≈∫wiƒôk√≥w z akcjami",
        "intro": "Teraz po≈ÇƒÖczymy d≈∫wiƒôki i wibracje z akcjami u≈ºytkownika - uko≈Ñczenie zadania, dodanie nowego itp.!",
        "code": "// Aktualizujemy klikniƒôcie zadania o d≈∫wiƒôki:\nlistView.setOnItemClickListener { _, view, position, _ ->\n    val task = taskList[position]\n    val wasCompleted = task.isCompleted\n    task.isCompleted = !task.isCompleted\n    \n    // Odtwarzamy efekty tylko przy uko≈Ñczeniu (nie przy cofaniu)\n    if (!wasCompleted && task.isCompleted) {\n        playTaskCompleteSound()\n        vibratePhone(150) // D≈Çu≈ºsza wibracja dla uko≈Ñczenia\n        \n        // Dodatkowy efekt wizualny\n        showCompletionAnimation(view)\n    } else if (wasCompleted && !task.isCompleted) {\n        vibratePhone(50) // Kr√≥tka wibracja dla cofniƒôcia\n    }\n    \n    animateTaskCompletion(view, task)\n    \n    Handler(Looper.getMainLooper()).postDelayed({\n        adapter.notifyDataSetChanged()\n        saveTasks()\n        updateStats()\n    }, 200)\n}\n\n// Dodajemy wibracjƒô przy dodawaniu zadania:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    if (taskTitle.isNotEmpty()) {\n        // ... kod dodawania zadania ...\n        \n        vibratePhone(80)\n        Toast.makeText(this, \"Dodano: $taskTitle\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "R√≥≈ºne akcje majƒÖ r√≥≈ºne efekty d≈∫wiƒôkowe i wibracje. Uko≈Ñczenie zadania = d≈Çuga wibracja + d≈∫wiƒôk, dodanie = ≈õrednia wibracja, cofniƒôcie = kr√≥tka wibracja."
      },
      "en": {
        "title": "Step 38: Integrating sounds with actions",
        "intro": "Now we'll connect sounds and vibrations with user actions - completing tasks, adding new ones etc.!",
        "code": "// We update task click with sounds:\nlistView.setOnItemClickListener { _, view, position, _ ->\n    val task = taskList[position]\n    val wasCompleted = task.isCompleted\n    task.isCompleted = !task.isCompleted\n    \n    // Play effects only when completing (not when undoing)\n    if (!wasCompleted && task.isCompleted) {\n        playTaskCompleteSound()\n        vibratePhone(150) // Longer vibration for completion\n        \n        // Additional visual effect\n        showCompletionAnimation(view)\n    } else if (wasCompleted && !task.isCompleted) {\n        vibratePhone(50) // Short vibration for undoing\n    }\n    \n    animateTaskCompletion(view, task)\n    \n    Handler(Looper.getMainLooper()).postDelayed({\n        adapter.notifyDataSetChanged()\n        saveTasks()\n        updateStats()\n    }, 200)\n}\n\n// Add vibration when adding task:\nbuttonAdd.setOnClickListener {\n    val taskTitle = editText.text.toString().trim()\n    if (taskTitle.isNotEmpty()) {\n        // ... task adding code ...\n        \n        vibratePhone(80)\n        Toast.makeText(this, \"Added: $taskTitle\", Toast.LENGTH_SHORT).show()\n    }\n}",
        "explanation": "Different actions have different sound effects and vibrations. Task completion = long vibration + sound, adding = medium vibration, undoing = short vibration."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-39",
      "pl": {
        "title": "Krok 39: Motywy kolorystyczne",
        "intro": "Dodamy r√≥≈ºne motywy kolorystyczne, ≈ºeby u≈ºytkownik m√≥g≈Ç personalizowaƒá wyglƒÖd aplikacji!",
        "code": "// Tworzymy enum dla motyw√≥w:\nenum class AppTheme(val id: Int, val name: String, val primaryColor: String, val backgroundColor: String) {\n    BLUE(0, \"Niebieski\", \"#2196F3\", \"#E3F2FD\"),\n    GREEN(1, \"Zielony\", \"#4CAF50\", \"#E8F5E8\"),\n    PURPLE(2, \"Fioletowy\", \"#9C27B0\", \"#F3E5F5\"),\n    ORANGE(3, \"Pomara≈Ñczowy\", \"#FF9800\", \"#FFF3E0\"),\n    DARK(4, \"Ciemny\", \"#424242\", \"#303030\")\n}\n\nclass MainActivity : AppCompatActivity() {\n    private var currentTheme = AppTheme.BLUE\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // ≈Åadujemy zapisany motyw\n        loadTheme()\n        applyTheme()\n        \n        setContentView(R.layout.activity_main)\n        // ... reszta kodu ...\n    }\n    \n    private fun loadTheme() {\n        val themeId = sharedPreferences.getInt(\"theme\", 0)\n        currentTheme = AppTheme.values().find { it.id == themeId } ?: AppTheme.BLUE\n    }\n    \n    private fun saveTheme() {\n        sharedPreferences.edit().putInt(\"theme\", currentTheme.id).apply()\n    }\n}",
        "explanation": "<strong>enum class</strong> definiuje sta≈Çe warto≈õci motyw√≥w. Ka≈ºdy motyw ma ID, nazwƒô i kolory. Zapisujemy wybrany motyw w SharedPreferences."
      },
      "en": {
        "title": "Step 39: Color themes",
        "intro": "We'll add different color themes so users can personalize the app's appearance!",
        "code": "// We create enum for themes:\nenum class AppTheme(val id: Int, val name: String, val primaryColor: String, val backgroundColor: String) {\n    BLUE(0, \"Blue\", \"#2196F3\", \"#E3F2FD\"),\n    GREEN(1, \"Green\", \"#4CAF50\", \"#E8F5E8\"),\n    PURPLE(2, \"Purple\", \"#9C27B0\", \"#F3E5F5\"),\n    ORANGE(3, \"Orange\", \"#FF9800\", \"#FFF3E0\"),\n    DARK(4, \"Dark\", \"#424242\", \"#303030\")\n}\n\nclass MainActivity : AppCompatActivity() {\n    private var currentTheme = AppTheme.BLUE\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Load saved theme\n        loadTheme()\n        applyTheme()\n        \n        setContentView(R.layout.activity_main)\n        // ... rest of code ...\n    }\n    \n    private fun loadTheme() {\n        val themeId = sharedPreferences.getInt(\"theme\", 0)\n        currentTheme = AppTheme.values().find { it.id == themeId } ?: AppTheme.BLUE\n    }\n    \n    private fun saveTheme() {\n        sharedPreferences.edit().putInt(\"theme\", currentTheme.id).apply()\n    }\n}",
        "explanation": "<strong>enum class</strong> defines constant theme values. Each theme has ID, name and colors. We save selected theme in SharedPreferences."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-40",
      "pl": {
        "title": "Krok 40: Aplikowanie motyw√≥w",
        "intro": "Teraz napiszemy funkcjƒô, kt√≥ra zastosuje wybrany motyw do interfejsu aplikacji!",
        "code": "// Dodajemy funkcjƒô aplikowania motywu:\nprivate fun applyTheme() {\n    // Zmieniamy kolor paska akcji je≈õli istnieje\n    supportActionBar?.setBackgroundDrawable(\n        ColorDrawable(Color.parseColor(currentTheme.primaryColor))\n    )\n    \n    // Zmieniamy kolor statusu (wymaga API 21+)\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n        window.statusBarColor = Color.parseColor(currentTheme.primaryColor)\n    }\n}\n\n// Funkcja do zmiany kolor√≥w element√≥w UI:\nprivate fun updateUIColors() {\n    val rootLayout = findViewById<LinearLayout>(R.id.rootLayout)\n    rootLayout.setBackgroundColor(Color.parseColor(currentTheme.backgroundColor))\n    \n    val buttonAdd = findViewById<Button>(R.id.buttonAdd)\n    buttonAdd.setBackgroundColor(Color.parseColor(currentTheme.primaryColor))\n    \n    val buttonSort = findViewById<Button>(R.id.buttonSort)\n    buttonSort.setBackgroundColor(Color.parseColor(currentTheme.primaryColor))\n    \n    val textStats = findViewById<TextView>(R.id.textStats)\n    textStats.setBackgroundColor(Color.parseColor(currentTheme.backgroundColor))\n}\n\n// Dodajemy przycisk wyboru motywu:\nval buttonTheme = findViewById<Button>(R.id.buttonTheme)\nbuttonTheme.setOnClickListener {\n    showThemeDialog()\n}",
        "explanation": "<strong>ColorDrawable</strong> tworzy kolor jako drawable. <strong>window.statusBarColor</strong> zmienia kolor paska statusu telefonu. Aktualizujemy kolory wszystkich g≈Ç√≥wnych element√≥w."
      },
      "en": {
        "title": "Step 40: Applying themes",
        "intro": "Now we'll write a function that applies the selected theme to the app interface!",
        "code": "// We add theme applying function:\nprivate fun applyTheme() {\n    // Change action bar color if exists\n    supportActionBar?.setBackgroundDrawable(\n        ColorDrawable(Color.parseColor(currentTheme.primaryColor))\n    )\n    \n    // Change status color (requires API 21+)\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n        window.statusBarColor = Color.parseColor(currentTheme.primaryColor)\n    }\n}\n\n// Function to change UI element colors:\nprivate fun updateUIColors() {\n    val rootLayout = findViewById<LinearLayout>(R.id.rootLayout)\n    rootLayout.setBackgroundColor(Color.parseColor(currentTheme.backgroundColor))\n    \n    val buttonAdd = findViewById<Button>(R.id.buttonAdd)\n    buttonAdd.setBackgroundColor(Color.parseColor(currentTheme.primaryColor))\n    \n    val buttonSort = findViewById<Button>(R.id.buttonSort)\n    buttonSort.setBackgroundColor(Color.parseColor(currentTheme.primaryColor))\n    \n    val textStats = findViewById<TextView>(R.id.textStats)\n    textStats.setBackgroundColor(Color.parseColor(currentTheme.backgroundColor))\n}\n\n// Add theme selection button:\nval buttonTheme = findViewById<Button>(R.id.buttonTheme)\nbuttonTheme.setOnClickListener {\n    showThemeDialog()\n}",
        "explanation": "<strong>ColorDrawable</strong> creates color as drawable. <strong>window.statusBarColor</strong> changes phone status bar color. We update colors of all main elements."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-41",
      "pl": {
        "title": "Krok 41: Dialog wyboru motywu",
        "intro": "Stworzymy ≈Çadny dialog, w kt√≥rym u≈ºytkownik bƒôdzie m√≥g≈Ç wybraƒá sw√≥j ulubiony motyw kolorystyczny!",
        "code": "// Tworzymy dialog wyboru motywu:\nprivate fun showThemeDialog() {\n    val themeNames = AppTheme.values().map { it.name }.toTypedArray()\n    val currentIndex = AppTheme.values().indexOf(currentTheme)\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Wybierz motyw aplikacji\")\n        .setSingleChoiceItems(themeNames, currentIndex) { dialog, which ->\n            val selectedTheme = AppTheme.values()[which]\n            if (selectedTheme != currentTheme) {\n                currentTheme = selectedTheme\n                applyTheme()\n                updateUIColors()\n                saveTheme()\n                \n                // Aktualizujemy adapter, ≈ºeby lista te≈º mia≈Ça nowe kolory\n                adapter.notifyDataSetChanged()\n                \n                vibratePhone(60)\n                Toast.makeText(this, \"Zmieniono motyw na: ${selectedTheme.name}\", Toast.LENGTH_SHORT).show()\n            }\n            dialog.dismiss()\n        }\n        .setNegativeButton(\"Anuluj\", null)\n        .show()\n}\n\n// Dodajemy funkcjƒô do resetowania motywu:\nprivate fun resetToDefaultTheme() {\n    currentTheme = AppTheme.BLUE\n    applyTheme()\n    updateUIColors()\n    saveTheme()\n    adapter.notifyDataSetChanged()\n}",
        "explanation": "<strong>setSingleChoiceItems</strong> tworzy listƒô z opcjami do wyboru (radio buttons). <strong>indexOf</strong> znajduje pozycjƒô aktualnego motywu w li≈õcie."
      },
      "en": {
        "title": "Step 41: Theme selection dialog",
        "intro": "We'll create a nice dialog where users can choose their favorite color theme!",
        "code": "// We create theme selection dialog:\nprivate fun showThemeDialog() {\n    val themeNames = AppTheme.values().map { it.name }.toTypedArray()\n    val currentIndex = AppTheme.values().indexOf(currentTheme)\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Choose app theme\")\n        .setSingleChoiceItems(themeNames, currentIndex) { dialog, which ->\n            val selectedTheme = AppTheme.values()[which]\n            if (selectedTheme != currentTheme) {\n                currentTheme = selectedTheme\n                applyTheme()\n                updateUIColors()\n                saveTheme()\n                \n                // Update adapter so list also has new colors\n                adapter.notifyDataSetChanged()\n                \n                vibratePhone(60)\n                Toast.makeText(this, \"Changed theme to: ${selectedTheme.name}\", Toast.LENGTH_SHORT).show()\n            }\n            dialog.dismiss()\n        }\n        .setNegativeButton(\"Cancel\", null)\n        .show()\n}\n\n// Add function to reset theme:\nprivate fun resetToDefaultTheme() {\n    currentTheme = AppTheme.BLUE\n    applyTheme()\n    updateUIColors()\n    saveTheme()\n    adapter.notifyDataSetChanged()\n}",
        "explanation": "<strong>setSingleChoiceItems</strong> creates list with selectable options (radio buttons). <strong>indexOf</strong> finds position of current theme in list."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-42",
      "pl": {
        "title": "Krok 42: Eksport zada≈Ñ do pliku",
        "intro": "Dodamy mo≈ºliwo≈õƒá eksportu wszystkich zada≈Ñ do pliku tekstowego, ≈ºeby u≈ºytkownik m√≥g≈Ç je zapisaƒá lub udostƒôpniƒá!",
        "code": "// Dodajemy funkcjƒô eksportu:\nimport java.io.File\nimport java.io.FileWriter\nimport android.os.Environment\n\nprivate fun exportTasksToFile() {\n    try {\n        val fileName = \"moje_zadania_${SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault()).format(Date())}.txt\"\n        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\n        val file = File(downloadsDir, fileName)\n        \n        val fileWriter = FileWriter(file)\n        \n        // Nag≈Ç√≥wek pliku\n        fileWriter.append(\"MOJE ZADANIA - EKSPORT\\n\")\n        fileWriter.append(\"Data eksportu: ${SimpleDateFormat(\"dd.MM.yyyy HH:mm\", Locale.getDefault()).format(Date())}\\n\\n\")\n        \n        // Statystyki\n        val totalTasks = taskList.size\n        val completedTasks = taskList.count { it.isCompleted }\n        fileWriter.append(\"STATYSTYKI:\\n\")\n        fileWriter.append(\"Wszystkich zada≈Ñ: $totalTasks\\n\")\n        fileWriter.append(\"Uko≈Ñczonych: $completedTasks\\n\")\n        fileWriter.append(\"Do zrobienia: ${totalTasks - completedTasks}\\n\\n\")\n        \n        // Grupujemy zadania wed≈Çug kategorii\n        val tasksByCategory = taskList.groupBy { it.category }\n        \n        tasksByCategory.forEach { (category, tasks) ->\n            fileWriter.append(\"=== $category ===\\n\")\n            tasks.forEach { task ->\n                val status = if (task.isCompleted) \"[‚úì]\" else \"[ ]\"\n                val priority = when (task.priority) {\n                    3 -> \"WYSOKI\"\n                    2 -> \"≈öREDNI\"\n                    else -> \"NISKI\"\n                }\n                val dateText = task.dueDate?.let { \n                    \" (termin: ${SimpleDateFormat(\"dd.MM.yyyy\", Locale.getDefault()).format(it)})\"\n                } ?: \"\"\n                \n                fileWriter.append(\"$status ${task.title} - Priorytet: $priority$dateText\\n\")\n            }\n            fileWriter.append(\"\\n\")\n        }\n        \n        fileWriter.close()\n        \n        Toast.makeText(this, \"Zadania wyeksportowane do: $fileName\", Toast.LENGTH_LONG).show()\n        \n    } catch (e: Exception) {\n        Toast.makeText(this, \"B≈ÇƒÖd eksportu: ${e.message}\", Toast.LENGTH_LONG).show()\n    }\n}",
        "explanation": "<strong>FileWriter</strong> zapisuje tekst do pliku. <strong>groupBy</strong> grupuje zadania wed≈Çug kategorii. <strong>Environment.DIRECTORY_DOWNLOADS</strong> to folder Pobrane w telefonie."
      },
      "en": {
        "title": "Step 42: Export tasks to file",
        "intro": "We'll add the ability to export all tasks to a text file so users can save or share them!",
        "code": "// We add export function:\nimport java.io.File\nimport java.io.FileWriter\nimport android.os.Environment\n\nprivate fun exportTasksToFile() {\n    try {\n        val fileName = \"my_tasks_${SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault()).format(Date())}.txt\"\n        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\n        val file = File(downloadsDir, fileName)\n        \n        val fileWriter = FileWriter(file)\n        \n        // File header\n        fileWriter.append(\"MY TASKS - EXPORT\\n\")\n        fileWriter.append(\"Export date: ${SimpleDateFormat(\"dd.MM.yyyy HH:mm\", Locale.getDefault()).format(Date())}\\n\\n\")\n        \n        // Statistics\n        val totalTasks = taskList.size\n        val completedTasks = taskList.count { it.isCompleted }\n        fileWriter.append(\"STATISTICS:\\n\")\n        fileWriter.append(\"Total tasks: $totalTasks\\n\")\n        fileWriter.append(\"Completed: $completedTasks\\n\")\n        fileWriter.append(\"To do: ${totalTasks - completedTasks}\\n\\n\")\n        \n        // Group tasks by category\n        val tasksByCategory = taskList.groupBy { it.category }\n        \n        tasksByCategory.forEach { (category, tasks) ->\n            fileWriter.append(\"=== $category ===\\n\")\n            tasks.forEach { task ->\n                val status = if (task.isCompleted) \"[‚úì]\" else \"[ ]\"\n                val priority = when (task.priority) {\n                    3 -> \"HIGH\"\n                    2 -> \"MEDIUM\"\n                    else -> \"LOW\"\n                }\n                val dateText = task.dueDate?.let { \n                    \" (due: ${SimpleDateFormat(\"dd.MM.yyyy\", Locale.getDefault()).format(it)})\"\n                } ?: \"\"\n                \n                fileWriter.append(\"$status ${task.title} - Priority: $priority$dateText\\n\")\n            }\n            fileWriter.append(\"\\n\")\n        }\n        \n        fileWriter.close()\n        \n        Toast.makeText(this, \"Tasks exported to: $fileName\", Toast.LENGTH_LONG).show()\n        \n    } catch (e: Exception) {\n        Toast.makeText(this, \"Export error: ${e.message}\", Toast.LENGTH_LONG).show()\n    }\n}",
        "explanation": "<strong>FileWriter</strong> writes text to file. <strong>groupBy</strong> groups tasks by category. <strong>Environment.DIRECTORY_DOWNLOADS</strong> is the Downloads folder on phone."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-43",
      "pl": {
        "title": "Krok 43: Menu opcji aplikacji",
        "intro": "Stworzymy menu opcji z przydatnymi funkcjami jak eksport, zmiana motywu i ustawienia!",
        "code": "// Tworzymy plik menu/main_menu.xml:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n    \n    <item\n        android:id=\"@+id/action_export\"\n        android:title=\"Eksportuj zadania\"\n        android:icon=\"@drawable/ic_export\"\n        app:showAsAction=\"ifRoom\" />\n    \n    <item\n        android:id=\"@+id/action_theme\"\n        android:title=\"Zmie≈Ñ motyw\"\n        android:icon=\"@drawable/ic_palette\"\n        app:showAsAction=\"ifRoom\" />\n        \n    <item\n        android:id=\"@+id/action_stats\"\n        android:title=\"Statystyki\"\n        android:icon=\"@drawable/ic_stats\" />\n        \n    <item\n        android:id=\"@+id/action_clear_completed\"\n        android:title=\"Usu≈Ñ uko≈Ñczone\" />\n        \n    <item\n        android:id=\"@+id/action_about\"\n        android:title=\"O aplikacji\" />\n        \n</menu>\n\n// W MainActivity.kt dodajemy obs≈Çugƒô menu:\noverride fun onCreateOptionsMenu(menu: Menu?): Boolean {\n    menuInflater.inflate(R.menu.main_menu, menu)\n    return true\n}\n\noverride fun onOptionsItemSelected(item: MenuItem): Boolean {\n    when (item.itemId) {\n        R.id.action_export -> {\n            exportTasksToFile()\n            return true\n        }\n        R.id.action_theme -> {\n            showThemeDialog()\n            return true\n        }\n        R.id.action_stats -> {\n            showDetailedStats()\n            return true\n        }\n        R.id.action_clear_completed -> {\n            clearCompletedTasks()\n            return true\n        }\n        R.id.action_about -> {\n            showAboutDialog()\n            return true\n        }\n    }\n    return super.onOptionsItemSelected(item)\n}",
        "explanation": "<strong>onCreateOptionsMenu</strong> tworzy menu na pasku akcji. <strong>onOptionsItemSelected</strong> obs≈Çuguje klikniƒôcia w opcje menu. <strong>when</strong> sprawdza, kt√≥ra opcja zosta≈Ça wybrana."
      },
      "en": {
        "title": "Step 43: App options menu",
        "intro": "We'll create an options menu with useful functions like export, theme change and settings!",
        "code": "// We create menu/main_menu.xml file:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n    \n    <item\n        android:id=\"@+id/action_export\"\n        android:title=\"Export tasks\"\n        android:icon=\"@drawable/ic_export\"\n        app:showAsAction=\"ifRoom\" />\n    \n    <item\n        android:id=\"@+id/action_theme\"\n        android:title=\"Change theme\"\n        android:icon=\"@drawable/ic_palette\"\n        app:showAsAction=\"ifRoom\" />\n        \n    <item\n        android:id=\"@+id/action_stats\"\n        android:title=\"Statistics\"\n        android:icon=\"@drawable/ic_stats\" />\n        \n    <item\n        android:id=\"@+id/action_clear_completed\"\n        android:title=\"Remove completed\" />\n        \n    <item\n        android:id=\"@+id/action_about\"\n        android:title=\"About app\" />\n        \n</menu>\n\n// In MainActivity.kt we add menu handling:\noverride fun onCreateOptionsMenu(menu: Menu?): Boolean {\n    menuInflater.inflate(R.menu.main_menu, menu)\n    return true\n}\n\noverride fun onOptionsItemSelected(item: MenuItem): Boolean {\n    when (item.itemId) {\n        R.id.action_export -> {\n            exportTasksToFile()\n            return true\n        }\n        R.id.action_theme -> {\n            showThemeDialog()\n            return true\n        }\n        R.id.action_stats -> {\n            showDetailedStats()\n            return true\n        }\n        R.id.action_clear_completed -> {\n            clearCompletedTasks()\n            return true\n        }\n        R.id.action_about -> {\n            showAboutDialog()\n            return true\n        }\n    }\n    return super.onOptionsItemSelected(item)\n}",
        "explanation": "<strong>onCreateOptionsMenu</strong> creates menu on action bar. <strong>onOptionsItemSelected</strong> handles menu option clicks. <strong>when</strong> checks which option was selected."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
	{
	  "id": "step-44",
      "pl": {
        "title": "Krok 44: Szczeg√≥≈Çowe statystyki",
        "intro": "Stworzymy okno z dok≈Çadnymi statystykami pokazujƒÖcymi postƒôpy u≈ºytkownika!",
        "code": "// Dodajemy funkcjƒô szczeg√≥≈Çowych statystyk:\nprivate fun showDetailedStats() {\n    val totalTasks = taskList.size\n    val completedTasks = taskList.count { it.isCompleted }\n    val pendingTasks = totalTasks - completedTasks\n    val overdueTasks = taskList.count { it.isOverdue() }\n    \n    // Statystyki wed≈Çug kategorii\n    val categoryStats = taskList.groupBy { it.category }.mapValues { (_, tasks) ->\n        \"${tasks.count { it.isCompleted }}/${tasks.size}\"\n    }\n    \n    // Statystyki wed≈Çug priorytetu\n    val highPriorityCompleted = taskList.count { it.priority == 3 && it.isCompleted }\n    val highPriorityTotal = taskList.count { it.priority == 3 }\n    val mediumPriorityCompleted = taskList.count { it.priority == 2 && it.isCompleted }\n    val mediumPriorityTotal = taskList.count { it.priority == 2 }\n    val lowPriorityCompleted = taskList.count { it.priority == 1 && it.isCompleted }\n    val lowPriorityTotal = taskList.count { it.priority == 1 }\n    \n    val progressPercent = if (totalTasks > 0) (completedTasks * 100) / totalTasks else 0\n    \n    val statsMessage = StringBuilder()\n    statsMessage.append(\"üìä SZCZEG√ì≈ÅOWE STATYSTYKI\\n\\n\")\n    statsMessage.append(\"üéØ OG√ìLNE:\\n\")\n    statsMessage.append(\"‚Ä¢ Wszystkich zada≈Ñ: $totalTasks\\n\")\n    statsMessage.append(\"‚Ä¢ Uko≈Ñczonych: $completedTasks ($progressPercent%)\\n\")\n    statsMessage.append(\"‚Ä¢ Do zrobienia: $pendingTasks\\n\")\n    if (overdueTasks > 0) {\n        statsMessage.append(\"‚Ä¢ ‚ö†Ô∏è Przeterminowanych: $overdueTasks\\n\")\n    }\n    \n    statsMessage.append(\"\\nüìÇ WED≈ÅUG KATEGORII:\\n\")\n    categoryStats.forEach { (category, stats) ->\n        statsMessage.append(\"‚Ä¢ $category: $stats\\n\")\n    }\n    \n    statsMessage.append(\"\\nüéñÔ∏è WED≈ÅUG PRIORYTETU:\\n\")\n    statsMessage.append(\"‚Ä¢ üî¥ Wysoki: $highPriorityCompleted/$highPriorityTotal\\n\")\n    statsMessage.append(\"‚Ä¢ üü° ≈öredni: $mediumPriorityCompleted/$mediumPriorityTotal\\n\")\n    statsMessage.append(\"‚Ä¢ üü¢ Niski: $lowPriorityCompleted/$lowPriorityTotal\\n\")\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Statystyki\")\n        .setMessage(statsMessage.toString())\n        .setPositiveButton(\"OK\", null)\n        .show()\n}",
        "explanation": "<strong>StringBuilder</strong> efektywnie buduje d≈Çugi tekst. <strong>mapValues</strong> przekszta≈Çca warto≈õci w mapie. Pokazujemy szczeg√≥≈Çowe statystyki z emoji dla lepszego wyglƒÖdu."
      },
      "en": {
        "title": "Step 44: Detailed statistics",
        "intro": "We'll create a window with detailed statistics showing user progress!",
        "code": "// We add detailed statistics function:\nprivate fun showDetailedStats() {\n    val totalTasks = taskList.size\n    val completedTasks = taskList.count { it.isCompleted }\n    val pendingTasks = totalTasks - completedTasks\n    val overdueTasks = taskList.count { it.isOverdue() }\n    \n    // Statistics by category\n    val categoryStats = taskList.groupBy { it.category }.mapValues { (_, tasks) ->\n        \"${tasks.count { it.isCompleted }}/${tasks.size}\"\n    }\n    \n    // Statistics by priority\n    val highPriorityCompleted = taskList.count { it.priority == 3 && it.isCompleted }\n    val highPriorityTotal = taskList.count { it.priority == 3 }\n    val mediumPriorityCompleted = taskList.count { it.priority == 2 && it.isCompleted }\n    val mediumPriorityTotal = taskList.count { it.priority == 2 }\n    val lowPriorityCompleted = taskList.count { it.priority == 1 && it.isCompleted }\n    val lowPriorityTotal = taskList.count { it.priority == 1 }\n    \n    val progressPercent = if (totalTasks > 0) (completedTasks * 100) / totalTasks else 0\n    \n    val statsMessage = StringBuilder()\n    statsMessage.append(\"üìä DETAILED STATISTICS\\n\\n\")\n    statsMessage.append(\"üéØ GENERAL:\\n\")\n    statsMessage.append(\"‚Ä¢ Total tasks: $totalTasks\\n\")\n    statsMessage.append(\"‚Ä¢ Completed: $completedTasks ($progressPercent%)\\n\")\n    statsMessage.append(\"‚Ä¢ To do: $pendingTasks\\n\")\n    if (overdueTasks > 0) {\n        statsMessage.append(\"‚Ä¢ ‚ö†Ô∏è Overdue: $overdueTasks\\n\")\n    }\n    \n    statsMessage.append(\"\\nüìÇ BY CATEGORY:\\n\")\n    categoryStats.forEach { (category, stats) ->\n        statsMessage.append(\"‚Ä¢ $category: $stats\\n\")\n    }\n    \n    statsMessage.append(\"\\nüéñÔ∏è BY PRIORITY:\\n\")\n    statsMessage.append(\"‚Ä¢ üî¥ High: $highPriorityCompleted/$highPriorityTotal\\n\")\n    statsMessage.append(\"‚Ä¢ üü° Medium: $mediumPriorityCompleted/$mediumPriorityTotal\\n\")\n    statsMessage.append(\"‚Ä¢ üü¢ Low: $lowPriorityCompleted/$lowPriorityTotal\\n\")\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Statistics\")\n        .setMessage(statsMessage.toString())\n        .setPositiveButton(\"OK\", null)\n        .show()\n}",
        "explanation": "<strong>StringBuilder</strong> efficiently builds long text. <strong>mapValues</strong> transforms values in map. We show detailed statistics with emoji for better appearance."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-45",
      "pl": {
        "title": "Krok 45: Usuwanie uko≈Ñczonych zada≈Ñ",
        "intro": "Dodamy funkcjƒô czyszczenia listy z uko≈Ñczonych zada≈Ñ, ≈ºeby utrzymaƒá porzƒÖdek!",
        "code": "// Dodajemy funkcjƒô usuwania uko≈Ñczonych zada≈Ñ:\nprivate fun clearCompletedTasks() {\n    val completedCount = taskList.count { it.isCompleted }\n    \n    if (completedCount == 0) {\n        Toast.makeText(this, \"Brak uko≈Ñczonych zada≈Ñ do usuniƒôcia\", Toast.LENGTH_SHORT).show()\n        return\n    }\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Usu≈Ñ uko≈Ñczone zadania\")\n        .setMessage(\"Czy chcesz usunƒÖƒá wszystkie $completedCount uko≈Ñczonych zada≈Ñ?\\n\\nTej operacji nie mo≈ºna cofnƒÖƒá!\")\n        .setIcon(R.drawable.ic_warning)\n        .setPositiveButton(\"Usu≈Ñ\") { _, _ ->\n            val removedTasks = taskList.filter { it.isCompleted }\n            taskList.removeAll { it.isCompleted }\n            \n            adapter.notifyDataSetChanged()\n            saveTasks()\n            updateStats()\n            \n            // Pokazujemy animacjƒô\n            vibratePhone(100)\n            \n            val message = \"Usuniƒôto $completedCount zada≈Ñ:\\n\" + \n                removedTasks.take(3).joinToString(\"\\n\") { \"‚Ä¢ ${it.title}\" } +\n                if (removedTasks.size > 3) \"\\n... i ${removedTasks.size - 3} wiƒôcej\" else \"\"\n            \n            Toast.makeText(this, \"Usuniƒôto $completedCount zada≈Ñ\", Toast.LENGTH_LONG).show()\n            \n            // Opcjonalnie pokazujemy szczeg√≥≈Çy\n            showTasksRemovedDialog(message)\n        }\n        .setNegativeButton(\"Anuluj\", null)\n        .show()\n}\n\nprivate fun showTasksRemovedDialog(message: String) {\n    AlertDialog.Builder(this)\n        .setTitle(\"Zadania zosta≈Çy usuniƒôte\")\n        .setMessage(message)\n        .setIcon(R.drawable.ic_check_circle)\n        .setPositiveButton(\"OK\", null)\n        .show()\n}",
        "explanation": "<strong>removeAll</strong> usuwa wszystkie elementy spe≈ÇniajƒÖce warunek. <strong>take(3)</strong> bierze tylko pierwsze 3 elementy. <strong>joinToString</strong> ≈ÇƒÖczy elementy w tekst."
      },
      "en": {
        "title": "Step 45: Removing completed tasks",
        "intro": "We'll add a function to clean the list of completed tasks to keep things organized!",
        "code": "// We add completed tasks removal function:\nprivate fun clearCompletedTasks() {\n    val completedCount = taskList.count { it.isCompleted }\n    \n    if (completedCount == 0) {\n        Toast.makeText(this, \"No completed tasks to remove\", Toast.LENGTH_SHORT).show()\n        return\n    }\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Remove completed tasks\")\n        .setMessage(\"Do you want to remove all $completedCount completed tasks?\\n\\nThis operation cannot be undone!\")\n        .setIcon(R.drawable.ic_warning)\n        .setPositiveButton(\"Remove\") { _, _ ->\n            val removedTasks = taskList.filter { it.isCompleted }\n            taskList.removeAll { it.isCompleted }\n            \n            adapter.notifyDataSetChanged()\n            saveTasks()\n            updateStats()\n            \n            // Show animation\n            vibratePhone(100)\n            \n            val message = \"Removed $completedCount tasks:\\n\" + \n                removedTasks.take(3).joinToString(\"\\n\") { \"‚Ä¢ ${it.title}\" } +\n                if (removedTasks.size > 3) \"\\n... and ${removedTasks.size - 3} more\" else \"\"\n            \n            Toast.makeText(this, \"Removed $completedCount tasks\", Toast.LENGTH_LONG).show()\n            \n            // Optionally show details\n            showTasksRemovedDialog(message)\n        }\n        .setNegativeButton(\"Cancel\", null)\n        .show()\n}\n\nprivate fun showTasksRemovedDialog(message: String) {\n    AlertDialog.Builder(this)\n        .setTitle(\"Tasks have been removed\")\n        .setMessage(message)\n        .setIcon(R.drawable.ic_check_circle)\n        .setPositiveButton(\"OK\", null)\n        .show()\n}",
        "explanation": "<strong>removeAll</strong> removes all elements meeting condition. <strong>take(3)</strong> takes only first 3 elements. <strong>joinToString</strong> joins elements into text."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-46",
      "pl": {
        "title": "Krok 46: Dialog \"O aplikacji\"",
        "intro": "Stworzymy ≈Çadny dialog z informacjami o aplikacji, wersji i autorze!",
        "code": "// Tworzymy dialog \"O aplikacji\":\nprivate fun showAboutDialog() {\n    val aboutMessage = \"\"\"\n        üì± M√≥j Planner v1.0\n        \n        üéØ Aplikacja do zarzƒÖdzania zadaniami stworzona w Kotlin!\n        \n        ‚ú® Funkcje:\n        ‚Ä¢ Dodawanie i usuwanie zada≈Ñ\n        ‚Ä¢ Kategorie i priorytety\n        ‚Ä¢ Terminy wykonania\n        ‚Ä¢ Kolorowe motywy\n        ‚Ä¢ Statystyki postƒôp√≥w\n        ‚Ä¢ Eksport do pliku\n        ‚Ä¢ Powiadomienia\n        \n        üë®‚Äçüíª Stworzone podczas nauki programowania Android\n        \n        üîß Technologie:\n        ‚Ä¢ Kotlin\n        ‚Ä¢ Android SDK\n        ‚Ä¢ Material Design\n        \n        üìÖ ${SimpleDateFormat(\"yyyy\", Locale.getDefault()).format(Date())}\n    \"\"\".trimIndent()\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"O aplikacji\")\n        .setMessage(aboutMessage)\n        .setIcon(R.drawable.ic_info)\n        .setPositiveButton(\"Fajnie!\") { _, _ ->\n            // Ma≈Çe easter egg - konfetti!\n            showCelebration()\n        }\n        .setNeutralButton(\"OK\", null)\n        .show()\n}\n\n// Dodajemy ma≈ÇƒÖ animacjƒô ≈õwiƒôtowania:\nprivate fun showCelebration() {\n    Toast.makeText(this, \"üéâ Gratulacje! Stworzy≈Çe≈õ ≈õwietnƒÖ aplikacjƒô! üéâ\", Toast.LENGTH_LONG).show()\n    vibratePhone(200)\n    \n    // Mo≈ºemy dodaƒá konfetti lub inne efekty\n    val rootView = findViewById<View>(android.R.id.content)\n    rootView.animate()\n        .scaleX(1.05f)\n        .scaleY(1.05f)\n        .setDuration(200)\n        .withEndAction {\n            rootView.animate()\n                .scaleX(1.0f)\n                .scaleY(1.0f)\n                .setDuration(200)\n                .start()\n        }\n        .start()\n}",
        "explanation": "<strong>trimIndent()</strong> usuwa wciƒôcia z tekstu wielolinijkowego. <strong>animate()</strong> tworzy animacje widok√≥w. Easter egg dodaje element zabawy do aplikacji!"
      },
      "en": {
        "title": "Step 46: \"About app\" dialog",
        "intro": "We'll create a nice dialog with information about the app, version and author!",
        "code": "// We create \"About app\" dialog:\nprivate fun showAboutDialog() {\n    val aboutMessage = \"\"\"\n        üì± My Planner v1.0\n        \n        üéØ Task management app created in Kotlin!\n        \n        ‚ú® Features:\n        ‚Ä¢ Adding and removing tasks\n        ‚Ä¢ Categories and priorities\n        ‚Ä¢ Due dates\n        ‚Ä¢ Colorful themes\n        ‚Ä¢ Progress statistics\n        ‚Ä¢ File export\n        ‚Ä¢ Notifications\n        \n        üë®‚Äçüíª Created while learning Android programming\n        \n        üîß Technologies:\n        ‚Ä¢ Kotlin\n        ‚Ä¢ Android SDK\n        ‚Ä¢ Material Design\n        \n        üìÖ ${SimpleDateFormat(\"yyyy\", Locale.getDefault()).format(Date())}\n    \"\"\".trimIndent()\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"About app\")\n        .setMessage(aboutMessage)\n        .setIcon(R.drawable.ic_info)\n        .setPositiveButton(\"Cool!\") { _, _ ->\n            // Small easter egg - confetti!\n            showCelebration()\n        }\n        .setNeutralButton(\"OK\", null)\n        .show()\n}\n\n// Add small celebration animation:\nprivate fun showCelebration() {\n    Toast.makeText(this, \"üéâ Congratulations! You created a great app! üéâ\", Toast.LENGTH_LONG).show()\n    vibratePhone(200)\n    \n    // We can add confetti or other effects\n    val rootView = findViewById<View>(android.R.id.content)\n    rootView.animate()\n        .scaleX(1.05f)\n        .scaleY(1.05f)\n        .setDuration(200)\n        .withEndAction {\n            rootView.animate()\n                .scaleX(1.0f)\n                .scaleY(1.0f)\n                .setDuration(200)\n                .start()\n        }\n        .start()\n}",
        "explanation": "<strong>trimIndent()</strong> removes indentation from multiline text. <strong>animate()</strong> creates view animations. Easter egg adds fun element to the app!"
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-47",
      "pl": {
        "title": "Krok 47: Widget na ekran g≈Ç√≥wny",
        "intro": "Stworzymy ma≈Çy widget, kt√≥ry poka≈ºe liczbƒô zada≈Ñ do zrobienia na ekranie g≈Ç√≥wnym telefonu!",
        "code": "// Tworzymy klasƒô widgetu:\nimport android.appwidget.AppWidgetProvider\nimport android.appwidget.AppWidgetManager\nimport android.content.Context\nimport android.widget.RemoteViews\nimport android.content.SharedPreferences\nimport com.google.gson.Gson\nimport com.google.gson.reflect.TypeToken\n\nclass TaskWidget : AppWidgetProvider() {\n    \n    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {\n        for (appWidgetId in appWidgetIds) {\n            updateAppWidget(context, appWidgetManager, appWidgetId)\n        }\n    }\n    \n    private fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) {\n        // Wczytujemy zadania z SharedPreferences\n        val sharedPreferences = context.getSharedPreferences(\"TaskPrefs\", Context.MODE_PRIVATE)\n        val json = sharedPreferences.getString(\"tasks\", \"\")\n        \n        var pendingTasks = 0\n        var totalTasks = 0\n        \n        if (!json.isNullOrEmpty()) {\n            try {\n                val gson = Gson()\n                val type = object : TypeToken<List<Task>>() {}.type\n                val taskList: List<Task> = gson.fromJson(json, type)\n                \n                totalTasks = taskList.size\n                pendingTasks = taskList.count { !it.isCompleted }\n            } catch (e: Exception) {\n                // Je≈õli b≈ÇƒÖd, u≈ºywamy domy≈õlnych warto≈õci\n            }\n        }\n        \n        // Tworzymy widok widgetu\n        val views = RemoteViews(context.packageName, R.layout.task_widget)\n        views.setTextViewText(R.id.widget_pending_count, pendingTasks.toString())\n        views.setTextViewText(R.id.widget_total_count, totalTasks.toString())\n        \n        // Ustawiamy kolor w zale≈ºno≈õci od liczby zada≈Ñ\n        val backgroundColor = when {\n            pendingTasks == 0 && totalTasks > 0 -> android.graphics.Color.GREEN\n            pendingTasks > 5 -> android.graphics.Color.RED\n            pendingTasks > 2 -> android.graphics.Color.YELLOW\n            else -> android.graphics.Color.LTGRAY\n        }\n        views.setInt(R.id.widget_background, \"setBackgroundColor\", backgroundColor)\n        \n        appWidgetManager.updateAppWidget(appWidgetId, views)\n    }\n}",
        "explanation": "<strong>AppWidgetProvider</strong> to klasa bazowa dla widget√≥w. <strong>RemoteViews</strong> pozwala modyfikowaƒá widoki widgetu. Widget mo≈ºe odczytywaƒá dane z aplikacji i wy≈õwietlaƒá je na ekranie g≈Ç√≥wnym."
      },
      "en": {
        "title": "Step 47: Home screen widget",
        "intro": "We'll create a small widget that shows the number of tasks to do on the phone's home screen!",
        "code": "// We create widget class:\nimport android.appwidget.AppWidgetProvider\nimport android.appwidget.AppWidgetManager\nimport android.content.Context\nimport android.widget.RemoteViews\nimport android.content.SharedPreferences\nimport com.google.gson.Gson\nimport com.google.gson.reflect.TypeToken\n\nclass TaskWidget : AppWidgetProvider() {\n    \n    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {\n        for (appWidgetId in appWidgetIds) {\n            updateAppWidget(context, appWidgetManager, appWidgetId)\n        }\n    }\n    \n    private fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) {\n        // Load tasks from SharedPreferences\n        val sharedPreferences = context.getSharedPreferences(\"TaskPrefs\", Context.MODE_PRIVATE)\n        val json = sharedPreferences.getString(\"tasks\", \"\")\n        \n        var pendingTasks = 0\n        var totalTasks = 0\n        \n        if (!json.isNullOrEmpty()) {\n            try {\n                val gson = Gson()\n                val type = object : TypeToken<List<Task>>() {}.type\n                val taskList: List<Task> = gson.fromJson(json, type)\n                \n                totalTasks = taskList.size\n                pendingTasks = taskList.count { !it.isCompleted }\n            } catch (e: Exception) {\n                // If error, use default values\n            }\n        }\n        \n        // Create widget view\n        val views = RemoteViews(context.packageName, R.layout.task_widget)\n        views.setTextViewText(R.id.widget_pending_count, pendingTasks.toString())\n        views.setTextViewText(R.id.widget_total_count, totalTasks.toString())\n        \n        // Set color based on task count\n        val backgroundColor = when {\n            pendingTasks == 0 && totalTasks > 0 -> android.graphics.Color.GREEN\n            pendingTasks > 5 -> android.graphics.Color.RED\n            pendingTasks > 2 -> android.graphics.Color.YELLOW\n            else -> android.graphics.Color.LTGRAY\n        }\n        views.setInt(R.id.widget_background, \"setBackgroundColor\", backgroundColor)\n        \n        appWidgetManager.updateAppWidget(appWidgetId, views)\n    }\n}",
        "explanation": "<strong>AppWidgetProvider</strong> is base class for widgets. <strong>RemoteViews</strong> allows modifying widget views. Widget can read data from app and display it on home screen."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-48",
      "pl": {
        "title": "Krok 48: Layout widgetu i konfiguracja",
        "intro": "Stworzymy ≈Çadny layout dla naszego widgetu oraz plik konfiguracyjny!",
        "code": "<!-- Tworzymy plik layout/task_widget.xml: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/widget_background\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:padding=\"8dp\"\n    android:background=\"@drawable/widget_background\"\n    android:gravity=\"center\">\n\n    <ImageView\n        android:layout_width=\"24dp\"\n        android:layout_height=\"24dp\"\n        android:src=\"@drawable/ic_task_list\"\n        android:layout_marginBottom=\"4dp\" />\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Do zrobienia\"\n        android:textSize=\"10sp\"\n        android:textColor=\"#666666\"\n        android:layout_marginBottom=\"2dp\" />\n\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        android:gravity=\"center\">\n\n        <TextView\n            android:id=\"@+id/widget_pending_count\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"0\"\n            android:textSize=\"18sp\"\n            android:textStyle=\"bold\"\n            android:textColor=\"#333333\" />\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"/\"\n            android:textSize=\"14sp\"\n            android:textColor=\"#666666\"\n            android:layout_marginHorizontal=\"2dp\" />\n\n        <TextView\n            android:id=\"@+id/widget_total_count\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"0\"\n            android:textSize=\"14sp\"\n            android:textColor=\"#666666\" />\n    </LinearLayout>\n</LinearLayout>\n\n<!-- Tworzymy tak≈ºe plik xml/task_widget_info.xml: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:minWidth=\"72dp\"\n    android:minHeight=\"72dp\"\n    android:updatePeriodMillis=\"300000\"\n    android:initialLayout=\"@layout/task_widget\"\n    android:description=\"@string/widget_description\"\n    android:widgetCategory=\"home_screen\" />",
        "explanation": "Widget layout jest prosty i czytelny. <strong>updatePeriodMillis</strong> okre≈õla jak czƒôsto widget siƒô aktualizuje (300000ms = 5 minut). <strong>minWidth/Height</strong> to minimalne wymiary widgetu."
      },
      "en": {
        "title": "Step 48: Widget layout and configuration",
        "intro": "We'll create a nice layout for our widget and configuration file!",
        "code": "<!-- We create layout/task_widget.xml file: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/widget_background\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:padding=\"8dp\"\n    android:background=\"@drawable/widget_background\"\n    android:gravity=\"center\">\n\n    <ImageView\n        android:layout_width=\"24dp\"\n        android:layout_height=\"24dp\"\n        android:src=\"@drawable/ic_task_list\"\n        android:layout_marginBottom=\"4dp\" />\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"To do\"\n        android:textSize=\"10sp\"\n        android:textColor=\"#666666\"\n        android:layout_marginBottom=\"2dp\" />\n\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"horizontal\"\n        android:gravity=\"center\">\n\n        <TextView\n            android:id=\"@+id/widget_pending_count\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"0\"\n            android:textSize=\"18sp\"\n            android:textStyle=\"bold\"\n            android:textColor=\"#333333\" />\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"/\"\n            android:textSize=\"14sp\"\n            android:textColor=\"#666666\"\n            android:layout_marginHorizontal=\"2dp\" />\n\n        <TextView\n            android:id=\"@+id/widget_total_count\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"0\"\n            android:textSize=\"14sp\"\n            android:textColor=\"#666666\" />\n    </LinearLayout>\n</LinearLayout>\n\n<!-- We also create xml/task_widget_info.xml file: -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:minWidth=\"72dp\"\n    android:minHeight=\"72dp\"\n    android:updatePeriodMillis=\"300000\"\n    android:initialLayout=\"@layout/task_widget\"\n    android:description=\"@string/widget_description\"\n    android:widgetCategory=\"home_screen\" />",
        "explanation": "Widget layout is simple and readable. <strong>updatePeriodMillis</strong> determines how often widget updates (300000ms = 5 minutes). <strong>minWidth/Height</strong> are minimum widget dimensions."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
	{
      "id": "step-49",
      "pl": {
        "title": "Krok 49: Optymalizacja i ostatnie szlify",
        "intro": "Dodamy ostatnie poprawki i optymalizacje, ≈ºeby aplikacja dzia≈Ça≈Ça p≈Çynnie i profesjonalnie!",
        "code": "// Dodajemy funkcjƒô optymalizacji:\nclass MainActivity : AppCompatActivity() {\n    \n    // Optymalizujemy czyszczenie zasob√≥w\n    override fun onDestroy() {\n        super.onDestroy()\n        \n        // Zwolnij MediaPlayer\n        mediaPlayer?.release()\n        mediaPlayer = null\n    }\n    \n    // Dodajemy obs≈Çugƒô przycisku wstecz dla lepszego UX\n    override fun onBackPressed() {\n        if (currentFilter != \"Wszystkie\") {\n            // Je≈õli jest aktywny filtr, najpierw go resetujemy\n            resetFilter()\n        } else {\n            // Pokazujemy dialog potwierdzenia wyj≈õcia\n            showExitDialog()\n        }\n    }\n    \n    private fun showExitDialog() {\n        AlertDialog.Builder(this)\n            .setTitle(\"Zamknij aplikacjƒô\")\n            .setMessage(\"Czy na pewno chcesz zamknƒÖƒá Planner?\")\n            .setPositiveButton(\"Tak\") { _, _ ->\n                finish()\n            }\n            .setNegativeButton(\"Nie\", null)\n            .show()\n    }\n    \n    // Automatyczne zapisywanie przy wstrzymaniu aplikacji\n    override fun onPause() {\n        super.onPause()\n        saveTasks() // Zapisz na wszelki wypadek\n    }\n    \n    // Aktualizacja widgetu przy wznawianiu\n    override fun onResume() {\n        super.onResume()\n        updateStats()\n        updateWidget() // Aktualizuj widget\n    }\n    \n    private fun updateWidget() {\n        val intent = Intent(this, TaskWidget::class.java)\n        intent.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE\n        sendBroadcast(intent)\n    }\n    \n    // Funkcja walidacji danych\n    private fun validateTaskInput(title: String): Boolean {\n        return when {\n            title.trim().isEmpty() -> {\n                Toast.makeText(this, \"Wpisz tytu≈Ç zadania\", Toast.LENGTH_SHORT).show()\n                false\n            }\n            title.length > 100 -> {\n                Toast.makeText(this, \"Tytu≈Ç zadania jest za d≈Çugi (max 100 znak√≥w)\", Toast.LENGTH_SHORT).show()\n                false\n            }\n            else -> true\n        }\n    }\n}",
        "explanation": "Optymalizacja to wa≈ºny krok! Zwalniamy zasoby w <strong>onDestroy()</strong>, zapisujemy dane w <strong>onPause()</strong> i walidujemy dane wej≈õciowe. To sprawia, ≈ºe aplikacja jest stabilna."
      },
      "en": {
        "title": "Step 49: Optimization and final touches",
        "intro": "We'll add final improvements and optimizations so the app runs smoothly and professionally!",
        "code": "// We add optimization function:\nclass MainActivity : AppCompatActivity() {\n    \n    // Optimize resource cleanup\n    override fun onDestroy() {\n        super.onDestroy()\n        \n        // Release MediaPlayer\n        mediaPlayer?.release()\n        mediaPlayer = null\n    }\n    \n    // Add back button handling for better UX\n    override fun onBackPressed() {\n        if (currentFilter != \"All\") {\n            // If filter is active, reset it first\n            resetFilter()\n        } else {\n            // Show exit confirmation dialog\n            showExitDialog()\n        }\n    }\n    \n    private fun showExitDialog() {\n        AlertDialog.Builder(this)\n            .setTitle(\"Close app\")\n            .setMessage(\"Are you sure you want to close Planner?\")\n            .setPositiveButton(\"Yes\") { _, _ ->\n                finish()\n            }\n            .setNegativeButton(\"No\", null)\n            .show()\n    }\n    \n    // Auto-save when app is paused\n    override fun onPause() {\n        super.onPause()\n        saveTasks() // Save just in case\n    }\n    \n    // Update widget when resuming\n    override fun onResume() {\n        super.onResume()\n        updateStats()\n        updateWidget() // Update widget\n    }\n    \n    private fun updateWidget() {\n        val intent = Intent(this, TaskWidget::class.java)\n        intent.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE\n        sendBroadcast(intent)\n    }\n    \n    // Data validation function\n    private fun validateTaskInput(title: String): Boolean {\n        return when {\n            title.trim().isEmpty() -> {\n                Toast.makeText(this, \"Enter task title\", Toast.LENGTH_SHORT).show()\n                false\n            }\n            title.length > 100 -> {\n                Toast.makeText(this, \"Task title too long (max 100 characters)\", Toast.LENGTH_SHORT).show()\n                false\n            }\n            else -> true\n        }\n    }\n}",
        "explanation": "Optimization is an important step! We release resources in <strong>onDestroy()</strong>, save data in <strong>onPause()</strong> and validate input data. This makes the app stable."
      },
      "buttonText": "Nastƒôpny krok ‚ñ∂Ô∏è"
    },
    {
      "id": "step-50",
      "pl": {
        "title": "Krok 50: Gratulacje! Twoja aplikacja jest gotowa! üéâ",
        "intro": "To by≈Ç ostatni krok! Stworzy≈Çe≈õ pe≈ÇnoprawnƒÖ aplikacjƒô Android w jƒôzyku Kotlin. Czas na podsumowanie i plany na przysz≈Ço≈õƒá!",
        "code": "// Manifest.xml - dodajemy wszystkie potrzebne uprawnienia:\n<uses-permission android:name=\"android.permission.VIBRATE\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n\n<application\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/AppTheme\">\n    \n    <activity\n        android:name=\".MainActivity\"\n        android:exported=\"true\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n    </activity>\n    \n    <receiver android:name=\".TaskWidget\">\n        <intent-filter>\n            <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n        </intent-filter>\n        <meta-data\n            android:name=\"android.appwidget.provider\"\n            android:resource=\"@xml/task_widget_info\" />\n    </receiver>\n</application>\n\n// Dodajemy funkcjƒô podsumowujƒÖcƒÖ:\nprivate fun showCompletionDialog() {\n    val message = \"\"\"\n        üèÜ GRATULACJE! üèÜ\n        \n        Uda≈Ço Ci siƒô stworzyƒá kompletnƒÖ aplikacjƒô Android!\n        \n        üì± Twoja aplikacja ma:\n        ‚úÖ ${taskList.size} zada≈Ñ\n        ‚úÖ ${AppTheme.values().size} motyw√≥w kolorystycznych\n        ‚úÖ Widget na ekran g≈Ç√≥wny\n        ‚úÖ Eksport do pliku\n        ‚úÖ Powiadomienia\n        ‚úÖ D≈∫wiƒôki i animacje\n        \n        üöÄ Co dalej?\n        ‚Ä¢ Dodaj wiƒôcej kategorii\n        ‚Ä¢ Stw√≥rz przypomnienia\n        ‚Ä¢ Udostƒôpnij aplikacjƒô znajomym\n        ‚Ä¢ Opublikuj w Google Play Store!\n        \n        Jeste≈õ prawdziwym programistƒÖ Android! üë®‚Äçüíª\n    \"\"\".trimIndent()\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"üéâ MISJA UKO≈ÉCZONA! üéâ\")\n        .setMessage(message)\n        .setPositiveButton(\"Super!\") { _, _ ->\n            showCelebration()\n        }\n        .setCancelable(false)\n        .show()\n}",
        "explanation": "To koniec naszej podr√≥≈ºy! Stworzy≈Çe≈õ prawdziwƒÖ aplikacjƒô z wieloma funkcjami. <strong>Manifest.xml</strong> definiuje uprawnienia aplikacji. Teraz mo≈ºesz dalej rozwijaƒá swojƒÖ aplikacjƒô!"
      },
      "en": {
        "title": "Step 50: Congratulations! Your app is ready! üéâ",
        "intro": "This was the final step! You've created a full-fledged Android app in Kotlin. Time for summary and future plans!",
        "code": "// Manifest.xml - add all necessary permissions:\n<uses-permission android:name=\"android.permission.VIBRATE\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n\n<application\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/AppTheme\">\n    \n    <activity\n        android:name=\".MainActivity\"\n        android:exported=\"true\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n    </activity>\n    \n    <receiver android:name=\".TaskWidget\">\n        <intent-filter>\n            <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n        </intent-filter>\n        <meta-data\n            android:name=\"android.appwidget.provider\"\n            android:resource=\"@xml/task_widget_info\" />\n    </receiver>\n</application>\n\n// Add completion summary function:\nprivate fun showCompletionDialog() {\n    val message = \"\"\"\n        üèÜ CONGRATULATIONS! üèÜ\n        \n        You've successfully created a complete Android app!\n        \n        üì± Your app has:\n        ‚úÖ ${taskList.size} tasks\n        ‚úÖ ${AppTheme.values().size} color themes\n        ‚úÖ Home screen widget\n        ‚úÖ File export\n        ‚úÖ Notifications\n        ‚úÖ Sounds and animations\n        \n        üöÄ What's next?\n        ‚Ä¢ Add more categories\n        ‚Ä¢ Create reminders\n        ‚Ä¢ Share app with friends\n        ‚Ä¢ Publish to Google Play Store!\n        \n        You're a real Android developer! üë®‚Äçüíª\n    \"\"\".trimIndent()\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"üéâ MISSION COMPLETED! üéâ\")\n        .setMessage(message)\n        .setPositiveButton(\"Awesome!\") { _, _ ->\n            showCelebration()\n        }\n        .setCancelable(false)\n        .show()\n}",
        "explanation": "This is the end of our journey! You've created a real app with many features. <strong>Manifest.xml</strong> defines app permissions. Now you can continue developing your app!"
      },
      "buttonText": "üéâ Zako≈Ñcz kurs! üéâ"
    }
  ],
  
  "conclusion": {
    "pl": {
      "title": "Gratulacje - Twoja pierwsza aplikacja Android!",
      "content": "Brawo! Stworzy≈Çe≈õ prawdziwƒÖ aplikacjƒô Android w jƒôzyku Kotlin! Tw√≥j planner ma ju≈º wiele funkcji:\n\n<strong>Co umie Twoja aplikacja:</strong>\n‚Ä¢ Dodawanie nowych zada≈Ñ z kategoriami\n‚Ä¢ Ustawianie priorytet√≥w (niski, ≈õredni, wysoki)\n‚Ä¢ Oznaczanie zada≈Ñ jako uko≈Ñczone\n‚Ä¢ Usuwanie niepotrzebnych zada≈Ñ\n‚Ä¢ Sortowanie wed≈Çug wa≈ºno≈õci\n‚Ä¢ Filtrowanie wed≈Çug kategorii\n‚Ä¢ Terminy wykonania zada≈Ñ\n‚Ä¢ Kolorowe motywy do wyboru\n‚Ä¢ Szczeg√≥≈Çowe statystyki postƒôp√≥w\n‚Ä¢ D≈∫wiƒôki i animacje\n‚Ä¢ Powiadomienia o wa≈ºnych zadaniach\n‚Ä¢ Eksport zada≈Ñ do pliku\n‚Ä¢ Widget na ekran g≈Ç√≥wny\n‚Ä¢ Profesjonalny wyglƒÖd z ikonami\n\n<strong>Czego siƒô nauczy≈Çe≈õ:</strong>\n‚Ä¢ Podstaw programowania w Kotlin\n‚Ä¢ Tworzenia interfejsu u≈ºytkownika w Android\n‚Ä¢ Pracy z bazami danych (SharedPreferences)\n‚Ä¢ Obs≈Çugi zdarze≈Ñ i gest√≥w\n‚Ä¢ Tworzenia animacji i efekt√≥w wizualnych\n‚Ä¢ Implementacji powiadomie≈Ñ\n‚Ä¢ Budowania niestandardowych adapter√≥w\n‚Ä¢ ZarzƒÖdzania cyklem ≈ºycia aplikacji\n‚Ä¢ Testowania i optymalizacji kodu\n‚Ä¢ Publikowania aplikacji\n\nTeraz mo≈ºesz u≈ºywaƒá swojej aplikacji do organizowania zada≈Ñ szkolnych, domowych i hobby! To dopiero poczƒÖtek Twojej przygody z programowaniem Android.",
      "nextProject": "Nastƒôpny projekt: Czy chcesz stworzyƒá aplikacjƒô pogodowƒÖ, grƒô mobilnƒÖ, czy mo≈ºe czat dla znajomych?"
    },
    "en": {
      "title": "Congratulations - Your first Android app!",
      "content": "Well done! You've created a real Android app in Kotlin! Your planner already has many features:\n\n<strong>What your app can do:</strong>\n‚Ä¢ Adding new tasks with categories\n‚Ä¢ Setting priorities (low, medium, high)\n‚Ä¢ Marking tasks as completed\n‚Ä¢ Deleting unnecessary tasks\n‚Ä¢ Sorting by importance\n‚Ä¢ Filtering by category\n‚Ä¢ Task due dates\n‚Ä¢ Colorful themes to choose from\n‚Ä¢ Detailed progress statistics\n‚Ä¢ Sounds and animations\n‚Ä¢ Notifications for important tasks\n‚Ä¢ Exporting tasks to file\n‚Ä¢ Home screen widget\n‚Ä¢ Professional look with icons\n\n<strong>What you learned:</strong>\n‚Ä¢ Kotlin programming basics\n‚Ä¢ Creating user interface in Android\n‚Ä¢ Working with databases (SharedPreferences)\n‚Ä¢ Handling events and gestures\n‚Ä¢ Creating animations and visual effects\n‚Ä¢ Implementing notifications\n‚Ä¢ Building custom adapters\n‚Ä¢ Managing app lifecycle\n‚Ä¢ Testing and code optimization\n‚Ä¢ App publishing\n\nNow you can use your app to organize school, home and hobby tasks! This is just the beginning of your Android programming adventure.",
      "nextProject": "Next project: Would you like to create a weather app, mobile game, or maybe a chat for friends?"
    }
  },
  "exercises": [
    {
      "id": "exercise-1",
      "pl": {
        "title": "ƒÜwiczenie 1: Dodaj wiƒôcej kategorii i podkategorie",
        "description": "Rozszerz system kategorii o nowe opcje jak 'Uniwersytet', 'Praca', 'Zdrowie' i 'Finanse'. Nastƒôpnie dodaj mo≈ºliwo≈õƒá tworzenia podkategorii - np. w kategorii 'Szko≈Ça' mo≈ºesz mieƒá 'Matematyka', 'Historia', 'Angielski'.",
        "hint": "Zmodyfikuj klasƒô Task o pole subcategory i stw√≥rz hierarchiczny spinner z kategoriami g≈Ç√≥wnymi i podkategoriami. U≈ºyj zagnie≈ºd≈ºonych list do przechowywania struktury kategorii."
      },
      "en": {
        "title": "Exercise 1: Add more categories and subcategories",
        "description": "Extend the category system with new options like 'University', 'Work', 'Health' and 'Finance'. Then add the ability to create subcategories - e.g. in 'School' category you can have 'Math', 'History', 'English'.",
        "hint": "Modify Task class with subcategory field and create hierarchical spinner with main categories and subcategories. Use nested lists to store category structure."
      }
    },
    {
      "id": "exercise-2",
      "pl": {
        "title": "ƒÜwiczenie 2: System powiadomie≈Ñ z harmonogramem",
        "description": "Rozbuduj system powiadomie≈Ñ o mo≈ºliwo≈õƒá ustawiania regularnych przypomnie≈Ñ. U≈ºytkownik powinien m√≥c wybraƒá, czy chce dostawaƒá powiadomienia codziennie, co tydzie≈Ñ, czy w okre≈õlone dni tygodnia.",
        "hint": "U≈ºyj AlarmManager do planowania powiadomie≈Ñ i stw√≥rz BroadcastReceiver do ich obs≈Çugi. Dodaj ustawienia w aplikacji dla czƒôstotliwo≈õci powiadomie≈Ñ."
      },
      "en": {
        "title": "Exercise 2: Notification system with scheduling",
        "description": "Expand the notification system with the ability to set regular reminders. User should be able to choose whether they want to receive notifications daily, weekly, or on specific days of the week.",
        "hint": "Use AlarmManager to schedule notifications and create BroadcastReceiver to handle them. Add settings in app for notification frequency."
      }
    },
    {
      "id": "exercise-3",
      "pl": {
        "title": "ƒÜwiczenie 3: Tryb ciemny i personalizacja",
        "description": "Dodaj pe≈Çny tryb ciemny do aplikacji oraz zaawansowane opcje personalizacji: mo≈ºliwo≈õƒá zmiany rozmiaru tekstu, wyboru czcionki, dostosowania kolor√≥w dla ka≈ºdej kategorii osobno.",
        "hint": "Utw√≥rz dedykowanƒÖ Activity dla ustawie≈Ñ. U≈ºyj r√≥≈ºnych plik√≥w styles.xml dla trybu jasnego i ciemnego. Zapisuj preferencje u≈ºytkownika w SharedPreferences."
      },
      "en": {
        "title": "Exercise 3: Dark mode and personalization",
        "description": "Add full dark mode to the app and advanced personalization options: ability to change text size, choose font, customize colors for each category separately.",
        "hint": "Create dedicated Settings Activity. Use different styles.xml files for light and dark mode. Save user preferences in SharedPreferences."
      }
    },
    {
      "id": "exercise-4",
      "pl": {
        "title": "ƒÜwiczenie 4: Synchronizacja w chmurze",
        "description": "Zintegruj aplikacjƒô z Firebase lub innƒÖ us≈ÇugƒÖ chmurowƒÖ, ≈ºeby u≈ºytkownik m√≥g≈Ç synchronizowaƒá swoje zadania miƒôdzy r√≥≈ºnymi urzƒÖdzeniami. Dodaj te≈º mo≈ºliwo≈õƒá udostƒôpniania list zada≈Ñ innym u≈ºytkownikom.",
        "hint": "U≈ºyj Firebase Firestore do przechowywania danych w chmurze i Firebase Auth do uwierzytelniania u≈ºytkownik√≥w. Zaimplementuj obs≈Çugƒô konflikt√≥w przy synchronizacji."
      },
      "en": {
        "title": "Exercise 4: Cloud synchronization",
        "description": "Integrate the app with Firebase or other cloud service so user can sync their tasks between different devices. Also add ability to share task lists with other users.",
        "hint": "Use Firebase Firestore to store data in cloud and Firebase Auth for user authentication. Implement conflict resolution for synchronization."
      }
    },
    {
      "id": "exercise-5",
      "pl": {
        "title": "ƒÜwiczenie 5: Analiza produktywno≈õci i raporty",
        "description": "Stw√≥rz system analizy produktywno≈õci z wykresami pokazujƒÖcymi postƒôpy w czasie. Dodaj tygodniowe i miesiƒôczne raporty, ≈õledzenie streaks (dni z rzƒôdu z uko≈Ñczonymi zadaniami) i por√≥wnania miƒôdzy kategoriami.",
        "hint": "U≈ºyj biblioteki MPAndroidChart do tworzenia wykres√≥w. Zapisuj historiƒô uko≈Ñczonych zada≈Ñ z datami i tw√≥rz agregacje danych dla r√≥≈ºnych okres√≥w."
      },
      "en": {
        "title": "Exercise 5: Productivity analysis and reports",
        "description": "Create productivity analysis system with charts showing progress over time. Add weekly and monthly reports, streak tracking (consecutive days with completed tasks) and comparisons between categories.",
        "hint": "Use MPAndroidChart library to create charts. Store history of completed tasks with dates and create data aggregations for different time periods."
      }
    },
	 {
      "id": "exercise-6",
      "pl": {
        "title": "ƒÜwiczenie 6: Dodaj pole notatek do zada≈Ñ",
        "description": "Rozszerz klasƒô Task o pole na notatki. U≈ºytkownik powinien m√≥c dodaƒá dodatkowe informacje do ka≈ºdego zadania, a notatki powinny byƒá widoczne w rozwijanym widoku pod tytu≈Çem zadania.",
        "hint": "Dodaj pole notes do data class Task, zmodyfikuj layout task_item.xml o ukryty TextView dla notatek i dodaj funkcjonalno≈õƒá rozwijania/zwijania przez klikniƒôcie.",
        "solution": "// 1. Modyfikacja klasy Task:\ndata class Task(\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"Og√≥lne\",\n    val priority: Int = 1,\n    var dueDate: Date? = null,\n    var notes: String = \"\" // Nowe pole\n)\n\n// 2. W layout/task_item.xml dodaj:\n<TextView\n    android:id=\"@+id/textNotes\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"\"\n    android:textSize=\"12sp\"\n    android:textColor=\"#888888\"\n    android:layout_marginTop=\"4dp\"\n    android:visibility=\"gone\" />\n\n// 3. W TaskAdapter:\nval textNotes = view.findViewById<TextView>(R.id.textNotes)\nif (task.notes.isNotEmpty()) {\n    textNotes.text = task.notes\n    textNotes.visibility = View.VISIBLE\n} else {\n    textNotes.visibility = View.GONE\n}\n\n// 4. Dodaj pole notatek w formularzu:\n<EditText\n    android:id=\"@+id/editTextNotes\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"Dodaj notatki (opcjonalnie)\"\n    android:minLines=\"2\"\n    android:maxLines=\"4\" />"
      },
      "en": {
        "title": "Exercise 6: Add notes field to tasks",
        "description": "Extend Task class with notes field. User should be able to add additional information to each task, and notes should be visible in expandable view under task title.",
        "hint": "Add notes field to Task data class, modify task_item.xml layout with hidden TextView for notes and add expand/collapse functionality on click.",
        "solution": "// 1. Task class modification:\ndata class Task(\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"General\",\n    val priority: Int = 1,\n    var dueDate: Date? = null,\n    var notes: String = \"\" // New field\n)\n\n// 2. In layout/task_item.xml add:\n<TextView\n    android:id=\"@+id/textNotes\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"\"\n    android:textSize=\"12sp\"\n    android:textColor=\"#888888\"\n    android:layout_marginTop=\"4dp\"\n    android:visibility=\"gone\" />\n\n// 3. In TaskAdapter:\nval textNotes = view.findViewById<TextView>(R.id.textNotes)\nif (task.notes.isNotEmpty()) {\n    textNotes.text = task.notes\n    textNotes.visibility = View.VISIBLE\n} else {\n    textNotes.visibility = View.GONE\n}\n\n// 4. Add notes field in form:\n<EditText\n    android:id=\"@+id/editTextNotes\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"Add notes (optional)\"\n    android:minLines=\"2\"\n    android:maxLines=\"4\" />"
      }
    },
    {
      "id": "exercise-7",
      "pl": {
        "title": "ƒÜwiczenie 7: Funkcja wyszukiwania zada≈Ñ",
        "description": "Dodaj pasek wyszukiwania, kt√≥ry pozwoli u≈ºytkownikowi znale≈∫ƒá zadania po tytule lub zawarto≈õci notatek. Wyszukiwanie powinno dzia≈Çaƒá w czasie rzeczywistym podczas wpisywania.",
        "hint": "U≈ºyj SearchView w menu lub EditText z TextWatcher. Filtruj listƒô zada≈Ñ na podstawie wprowadzonego tekstu i aktualizuj adapter.",
        "solution": "// 1. Dodaj SearchView do menu:\n<item\n    android:id=\"@+id/action_search\"\n    android:title=\"Szukaj\"\n    android:icon=\"@drawable/ic_search\"\n    app:showAsAction=\"ifRoom|collapseActionView\"\n    app:actionViewClass=\"androidx.appcompat.widget.SearchView\" />\n\n// 2. W MainActivity obs≈Çuga wyszukiwania:\noverride fun onCreateOptionsMenu(menu: Menu): Boolean {\n    menuInflater.inflate(R.menu.main_menu, menu)\n    \n    val searchItem = menu.findItem(R.id.action_search)\n    val searchView = searchItem.actionView as SearchView\n    \n    searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {\n        override fun onQueryTextSubmit(query: String?): Boolean {\n            return false\n        }\n        \n        override fun onQueryTextChange(newText: String?): Boolean {\n            searchTasks(newText ?: \"\")\n            return true\n        }\n    })\n    \n    return true\n}\n\nprivate fun searchTasks(query: String) {\n    val filteredTasks = if (query.isEmpty()) {\n        taskList\n    } else {\n        taskList.filter { task ->\n            task.title.contains(query, ignoreCase = true) ||\n            task.notes.contains(query, ignoreCase = true) ||\n            task.category.contains(query, ignoreCase = true)\n        }\n    }\n    \n    val searchAdapter = TaskAdapter(this, filteredTasks.toMutableList())\n    listView.adapter = searchAdapter\n}"
      },
      "en": {
        "title": "Exercise 7: Task search function",
        "description": "Add search bar that allows user to find tasks by title or notes content. Search should work in real-time while typing.",
        "hint": "Use SearchView in menu or EditText with TextWatcher. Filter task list based on entered text and update adapter.",
        "solution": "// 1. Add SearchView to menu:\n<item\n    android:id=\"@+id/action_search\"\n    android:title=\"Search\"\n    android:icon=\"@drawable/ic_search\"\n    app:showAsAction=\"ifRoom|collapseActionView\"\n    app:actionViewClass=\"androidx.appcompat.widget.SearchView\" />\n\n// 2. In MainActivity search handling:\noverride fun onCreateOptionsMenu(menu: Menu): Boolean {\n    menuInflater.inflate(R.menu.main_menu, menu)\n    \n    val searchItem = menu.findItem(R.id.action_search)\n    val searchView = searchItem.actionView as SearchView\n    \n    searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {\n        override fun onQueryTextSubmit(query: String?): Boolean {\n            return false\n        }\n        \n        override fun onQueryTextChange(newText: String?): Boolean {\n            searchTasks(newText ?: \"\")\n            return true\n        }\n    })\n    \n    return true\n}\n\nprivate fun searchTasks(query: String) {\n    val filteredTasks = if (query.isEmpty()) {\n        taskList\n    } else {\n        taskList.filter { task ->\n            task.title.contains(query, ignoreCase = true) ||\n            task.notes.contains(query, ignoreCase = true) ||\n            task.category.contains(query, ignoreCase = true)\n        }\n    }\n    \n    val searchAdapter = TaskAdapter(this, filteredTasks.toMutableList())\n    listView.adapter = searchAdapter\n}"
      }
    },
    {
      "id": "exercise-8",
      "pl": {
        "title": "ƒÜwiczenie 8: PrzeciƒÖganie zada≈Ñ do zmiany kolejno≈õci",
        "description": "Zaimplementuj funkcjƒô drag & drop, kt√≥ra pozwoli u≈ºytkownikowi zmieniaƒá kolejno≈õƒá zada≈Ñ przez przeciƒÖganie. U≈ºyj RecyclerView zamiast ListView dla lepszej funkcjonalno≈õci.",
        "hint": "Zamie≈Ñ ListView na RecyclerView, stw√≥rz RecyclerView.Adapter i u≈ºyj ItemTouchHelper do obs≈Çugi przeciƒÖgania.",
        "solution": "// 1. Zamie≈Ñ w layout na RecyclerView:\n<androidx.recyclerview.widget.RecyclerView\n    android:id=\"@+id/recyclerViewTasks\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"0dp\"\n    android:layout_weight=\"1\" />\n\n// 2. Stw√≥rz TaskRecyclerAdapter:\nclass TaskRecyclerAdapter(private val tasks: MutableList<Task>) : \n    RecyclerView.Adapter<TaskRecyclerAdapter.TaskViewHolder>() {\n    \n    class TaskViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val textTitle: TextView = view.findViewById(R.id.textTitle)\n        val textCategory: TextView = view.findViewById(R.id.textCategory)\n        val imageStatus: ImageView = view.findViewById(R.id.imageStatus)\n        val imagePriority: ImageView = view.findViewById(R.id.imagePriority)\n    }\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TaskViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.task_item, parent, false)\n        return TaskViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: TaskViewHolder, position: Int) {\n        val task = tasks[position]\n        holder.textTitle.text = task.title\n        holder.textCategory.text = task.category\n        // ... reszta bindowania\n    }\n    \n    override fun getItemCount() = tasks.size\n    \n    fun moveItem(fromPosition: Int, toPosition: Int) {\n        Collections.swap(tasks, fromPosition, toPosition)\n        notifyItemMoved(fromPosition, toPosition)\n    }\n}\n\n// 3. Dodaj ItemTouchHelper:\nval itemTouchHelper = ItemTouchHelper(object : ItemTouchHelper.SimpleCallback(\n    ItemTouchHelper.UP or ItemTouchHelper.DOWN, 0\n) {\n    override fun onMove(\n        recyclerView: RecyclerView,\n        viewHolder: RecyclerView.ViewHolder,\n        target: RecyclerView.ViewHolder\n    ): Boolean {\n        recyclerAdapter.moveItem(viewHolder.adapterPosition, target.adapterPosition)\n        return true\n    }\n    \n    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {}\n})\n\nitemTouchHelper.attachToRecyclerView(recyclerView)"
      },
      "en": {
        "title": "Exercise 8: Drag tasks to change order",
        "description": "Implement drag & drop function that allows user to change task order by dragging. Use RecyclerView instead of ListView for better functionality.",
        "hint": "Replace ListView with RecyclerView, create RecyclerView.Adapter and use ItemTouchHelper to handle dragging.",
        "solution": "// 1. Replace in layout with RecyclerView:\n<androidx.recyclerview.widget.RecyclerView\n    android:id=\"@+id/recyclerViewTasks\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"0dp\"\n    android:layout_weight=\"1\" />\n\n// 2. Create TaskRecyclerAdapter:\nclass TaskRecyclerAdapter(private val tasks: MutableList<Task>) : \n    RecyclerView.Adapter<TaskRecyclerAdapter.TaskViewHolder>() {\n    \n    class TaskViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val textTitle: TextView = view.findViewById(R.id.textTitle)\n        val textCategory: TextView = view.findViewById(R.id.textCategory)\n        val imageStatus: ImageView = view.findViewById(R.id.imageStatus)\n        val imagePriority: ImageView = view.findViewById(R.id.imagePriority)\n    }\n    \n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TaskViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.task_item, parent, false)\n        return TaskViewHolder(view)\n    }\n    \n    override fun onBindViewHolder(holder: TaskViewHolder, position: Int) {\n        val task = tasks[position]\n        holder.textTitle.text = task.title\n        holder.textCategory.text = task.category\n        // ... rest of binding\n    }\n    \n    override fun getItemCount() = tasks.size\n    \n    fun moveItem(fromPosition: Int, toPosition: Int) {\n        Collections.swap(tasks, fromPosition, toPosition)\n        notifyItemMoved(fromPosition, toPosition)\n    }\n}\n\n// 3. Add ItemTouchHelper:\nval itemTouchHelper = ItemTouchHelper(object : ItemTouchHelper.SimpleCallback(\n    ItemTouchHelper.UP or ItemTouchHelper.DOWN, 0\n) {\n    override fun onMove(\n        recyclerView: RecyclerView,\n        viewHolder: RecyclerView.ViewHolder,\n        target: RecyclerView.ViewHolder\n    ): Boolean {\n        recyclerAdapter.moveItem(viewHolder.adapterPosition, target.adapterPosition)\n        return true\n    }\n    \n    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {}\n})\n\nitemTouchHelper.attachToRecyclerView(recyclerView)"
      }
    },
    {
      "id": "exercise-9",
      "pl": {
        "title": "ƒÜwiczenie 9: Backup i restore danych",
        "description": "Dodaj funkcjƒô tworzenia kopii zapasowej wszystkich zada≈Ñ do pliku JSON oraz mo≈ºliwo≈õƒá przywracania danych z takiej kopii. Dodaj te≈º opcjƒô automatycznego backupu.",
        "hint": "U≈ºyj Gson do serializacji/deserializacji, FileProvider do bezpiecznego dostƒôpu do plik√≥w i ActivityResultLauncher do wybierania plik√≥w.",
        "solution": "// 1. Funkcja tworzenia backupu:\nprivate fun createBackup() {\n    try {\n        val backupData = BackupData(\n            tasks = taskList,\n            settings = getAppSettings(),\n            createdAt = Date()\n        )\n        \n        val gson = Gson()\n        val json = gson.toJson(backupData)\n        \n        val fileName = \"planner_backup_${SimpleDateFormat(\"yyyy-MM-dd_HH-mm\", Locale.getDefault()).format(Date())}.json\"\n        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\n        val file = File(downloadsDir, fileName)\n        \n        file.writeText(json)\n        \n        Toast.makeText(this, \"Backup utworzony: $fileName\", Toast.LENGTH_LONG).show()\n        \n    } catch (e: Exception) {\n        Toast.makeText(this, \"B≈ÇƒÖd tworzenia backupu: ${e.message}\", Toast.LENGTH_LONG).show()\n    }\n}\n\n// 2. Funkcja przywracania:\nprivate fun restoreBackup() {\n    val intent = Intent(Intent.ACTION_GET_CONTENT).apply {\n        type = \"application/json\"\n        addCategory(Intent.CATEGORY_OPENABLE)\n    }\n    \n    backupRestoreLauncher.launch(intent)\n}\n\nprivate val backupRestoreLauncher = registerForActivityResult(\n    ActivityResultContracts.StartActivityForResult()\n) { result ->\n    if (result.resultCode == Activity.RESULT_OK) {\n        result.data?.data?.let { uri ->\n            try {\n                val inputStream = contentResolver.openInputStream(uri)\n                val json = inputStream?.bufferedReader().use { it?.readText() }\n                \n                val gson = Gson()\n                val backupData = gson.fromJson(json, BackupData::class.java)\n                \n                // Poka≈º dialog potwierdzenia\n                AlertDialog.Builder(this)\n                    .setTitle(\"Przywr√≥ƒá backup\")\n                    .setMessage(\"Przywr√≥ciƒá backup z ${backupData.createdAt}?\\n\\nObecne dane zostanƒÖ zastƒÖpione!\")\n                    .setPositiveButton(\"Przywr√≥ƒá\") { _, _ ->\n                        taskList.clear()\n                        taskList.addAll(backupData.tasks)\n                        adapter.notifyDataSetChanged()\n                        saveTasks()\n                        updateStats()\n                        \n                        Toast.makeText(this, \"Backup przywr√≥cony pomy≈õlnie\", Toast.LENGTH_LONG).show()\n                    }\n                    .setNegativeButton(\"Anuluj\", null)\n                    .show()\n                    \n            } catch (e: Exception) {\n                Toast.makeText(this, \"B≈ÇƒÖd przywracania: ${e.message}\", Toast.LENGTH_LONG).show()\n            }\n        }\n    }\n}\n\n// 3. Data class dla backupu:\ndata class BackupData(\n    val tasks: List<Task>,\n    val settings: Map<String, String>,\n    val createdAt: Date\n)"
      },
      "en": {
        "title": "Exercise 9: Data backup and restore",
        "description": "Add function to create backup of all tasks to JSON file and ability to restore data from such backup. Also add automatic backup option.",
        "hint": "Use Gson for serialization/deserialization, FileProvider for secure file access and ActivityResultLauncher for file selection.",
        "solution": "// 1. Backup creation function:\nprivate fun createBackup() {\n    try {\n        val backupData = BackupData(\n            tasks = taskList,\n            settings = getAppSettings(),\n            createdAt = Date()\n        )\n        \n        val gson = Gson()\n        val json = gson.toJson(backupData)\n        \n        val fileName = \"planner_backup_${SimpleDateFormat(\"yyyy-MM-dd_HH-mm\", Locale.getDefault()).format(Date())}.json\"\n        val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)\n        val file = File(downloadsDir, fileName)\n        \n        file.writeText(json)\n        \n        Toast.makeText(this, \"Backup created: $fileName\", Toast.LENGTH_LONG).show()\n        \n    } catch (e: Exception) {\n        Toast.makeText(this, \"Backup creation error: ${e.message}\", Toast.LENGTH_LONG).show()\n    }\n}\n\n// 2. Restore function:\nprivate fun restoreBackup() {\n    val intent = Intent(Intent.ACTION_GET_CONTENT).apply {\n        type = \"application/json\"\n        addCategory(Intent.CATEGORY_OPENABLE)\n    }\n    \n    backupRestoreLauncher.launch(intent)\n}\n\nprivate val backupRestoreLauncher = registerForActivityResult(\n    ActivityResultContracts.StartActivityForResult()\n) { result ->\n    if (result.resultCode == Activity.RESULT_OK) {\n        result.data?.data?.let { uri ->\n            try {\n                val inputStream = contentResolver.openInputStream(uri)\n                val json = inputStream?.bufferedReader().use { it?.readText() }\n                \n                val gson = Gson()\n                val backupData = gson.fromJson(json, BackupData::class.java)\n                \n                // Show confirmation dialog\n                AlertDialog.Builder(this)\n                    .setTitle(\"Restore backup\")\n                    .setMessage(\"Restore backup from ${backupData.createdAt}?\\n\\nCurrent data will be replaced!\")\n                    .setPositiveButton(\"Restore\") { _, _ ->\n                        taskList.clear()\n                        taskList.addAll(backupData.tasks)\n                        adapter.notifyDataSetChanged()\n                        saveTasks()\n                        updateStats()\n                        \n                        Toast.makeText(this, \"Backup restored successfully\", Toast.LENGTH_LONG).show()\n                    }\n                    .setNegativeButton(\"Cancel\", null)\n                    .show()\n                    \n            } catch (e: Exception) {\n                Toast.makeText(this, \"Restore error: ${e.message}\", Toast.LENGTH_LONG).show()\n            }\n        }\n    }\n}\n\n// 3. Data class for backup:\ndata class BackupData(\n    val tasks: List<Task>,\n    val settings: Map<String, String>,\n    val createdAt: Date\n)"
      }
    },
	 {
      "id": "exercise-10",
      "pl": {
        "title": "ƒÜwiczenie 10: Subtasks (podzadania)",
        "description": "Dodaj mo≈ºliwo≈õƒá tworzenia podzada≈Ñ dla g≈Ç√≥wnych zada≈Ñ. Ka≈ºde zadanie mo≈ºe mieƒá listƒô mniejszych krok√≥w do wykonania. Podzadania powinny byƒá widoczne po rozwiniƒôciu zadania g≈Ç√≥wnego.",
        "hint": "Zmodyfikuj klasƒô Task o listƒô subtasks, stw√≥rz rekursywny adapter dla zagnie≈ºd≈ºonych zada≈Ñ i dodaj interfejs do zarzƒÖdzania podzadaniami.",
        "solution": "// 1. Modyfikacja klasy Task:\ndata class Task(\n    val id: String = UUID.randomUUID().toString(),\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"Og√≥lne\",\n    val priority: Int = 1,\n    var dueDate: Date? = null,\n    var notes: String = \"\",\n    var subtasks: MutableList<Subtask> = mutableListOf(),\n    var isExpanded: Boolean = false\n) {\n    fun getCompletionPercentage(): Int {\n        if (subtasks.isEmpty()) return if (isCompleted) 100 else 0\n        val completedCount = subtasks.count { it.isCompleted }\n        return (completedCount * 100) / subtasks.size\n    }\n}\n\ndata class Subtask(\n    val id: String = UUID.randomUUID().toString(),\n    val title: String,\n    var isCompleted: Boolean = false\n)\n\n// 2. Dialog dodawania podzadania:\nprivate fun showAddSubtaskDialog(task: Task) {\n    val editText = EditText(this)\n    editText.hint = \"Nazwa podzadania\"\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Dodaj podzadanie\")\n        .setView(editText)\n        .setPositiveButton(\"Dodaj\") { _, _ ->\n            val subtaskTitle = editText.text.toString().trim()\n            if (subtaskTitle.isNotEmpty()) {\n                task.subtasks.add(Subtask(title = subtaskTitle))\n                adapter.notifyDataSetChanged()\n                saveTasks()\n            }\n        }\n        .setNegativeButton(\"Anuluj\", null)\n        .show()\n}"
      },
      "en": {
        "title": "Exercise 10: Subtasks",
        "description": "Add ability to create subtasks for main tasks. Each task can have a list of smaller steps to complete. Subtasks should be visible after expanding the main task.",
        "hint": "Modify Task class with subtasks list, create recursive adapter for nested tasks and add interface for subtask management.",
        "solution": "// 1. Task class modification:\ndata class Task(\n    val id: String = UUID.randomUUID().toString(),\n    val title: String,\n    var isCompleted: Boolean = false,\n    val category: String = \"General\",\n    val priority: Int = 1,\n    var dueDate: Date? = null,\n    var notes: String = \"\",\n    var subtasks: MutableList<Subtask> = mutableListOf(),\n    var isExpanded: Boolean = false\n) {\n    fun getCompletionPercentage(): Int {\n        if (subtasks.isEmpty()) return if (isCompleted) 100 else 0\n        val completedCount = subtasks.count { it.isCompleted }\n        return (completedCount * 100) / subtasks.size\n    }\n}\n\ndata class Subtask(\n    val id: String = UUID.randomUUID().toString(),\n    val title: String,\n    var isCompleted: Boolean = false\n)\n\n// 2. Add subtask dialog:\nprivate fun showAddSubtaskDialog(task: Task) {\n    val editText = EditText(this)\n    editText.hint = \"Subtask name\"\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Add subtask\")\n        .setView(editText)\n        .setPositiveButton(\"Add\") { _, _ ->\n            val subtaskTitle = editText.text.toString().trim()\n            if (subtaskTitle.isNotEmpty()) {\n                task.subtasks.add(Subtask(title = subtaskTitle))\n                adapter.notifyDataSetChanged()\n                saveTasks()\n            }\n        }\n        .setNegativeButton(\"Cancel\", null)\n        .show()\n}"
      }
    },
    {
      "id": "exercise-11",
      "pl": {
        "title": "ƒÜwiczenie 11: System tag√≥w",
        "description": "Dodaj system tag√≥w do zada≈Ñ. U≈ºytkownik mo≈ºe dodawaƒá w≈Çasne tagi (np. #pilne, #≈Çatwe, #d≈Çugoterminowe) i filtrowaƒá zadania wed≈Çug tag√≥w. Tagi powinny byƒá wy≈õwietlane jako kolorowe chipsy.",
        "hint": "Dodaj pole tags do klasy Task, stw√≥rz TagInputView do dodawania tag√≥w oraz ChipGroup do wy≈õwietlania. Zaimplementuj filtrowanie wed≈Çug tag√≥w.",
        "solution": "// 1. Modyfikacja klasy Task:\ndata class Task(\n    // ... pozosta≈Çe pola ...\n    var tags: MutableSet<String> = mutableSetOf()\n) {\n    fun getTagsString(): String = tags.joinToString(\" \") { \"#$it\" }\n}\n\n// 2. Layout z ChipGroup dla tag√≥w:\n<com.google.android.material.chip.ChipGroup\n    android:id=\"@+id/chipGroupTags\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"8dp\"\n    app:singleLine=\"false\" />\n\n// 3. Funkcja dodawania tag√≥w:\nprivate fun addTagsToTask(task: Task, chipGroup: ChipGroup) {\n    chipGroup.removeAllViews()\n    \n    task.tags.forEach { tagName ->\n        val chip = Chip(this)\n        chip.text = \"#$tagName\"\n        chip.isCloseIconVisible = true\n        chip.setChipBackgroundColorResource(getTagColor(tagName))\n        \n        chip.setOnCloseIconClickListener {\n            task.tags.remove(tagName)\n            chipGroup.removeView(chip)\n            saveTasks()\n        }\n        \n        chipGroup.addView(chip)\n    }\n    \n    // Dodaj chip do dodawania nowych tag√≥w\n    val addChip = Chip(this)\n    addChip.text = \"+ Dodaj tag\"\n    addChip.setChipIconResource(R.drawable.ic_add)\n    addChip.setOnClickListener {\n        showAddTagDialog(task, chipGroup)\n    }\n    chipGroup.addView(addChip)\n}\n\n// 4. Dialog dodawania tagu:\nprivate fun showAddTagDialog(task: Task, chipGroup: ChipGroup) {\n    val editText = EditText(this)\n    editText.hint = \"Nazwa tagu (bez #)\"\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Dodaj tag\")\n        .setView(editText)\n        .setPositiveButton(\"Dodaj\") { _, _ ->\n            val tagName = editText.text.toString().trim().lowercase()\n            if (tagName.isNotEmpty() && !task.tags.contains(tagName)) {\n                task.tags.add(tagName)\n                addTagsToTask(task, chipGroup)\n                saveTasks()\n            }\n        }\n        .setNegativeButton(\"Anuluj\", null)\n        .show()\n}\n\n// 5. Funkcja zwracajƒÖca kolor dla tagu:\nprivate fun getTagColor(tagName: String): Int {\n    return when (tagName.hashCode() % 6) {\n        0 -> R.color.tag_blue\n        1 -> R.color.tag_green\n        2 -> R.color.tag_orange\n        3 -> R.color.tag_purple\n        4 -> R.color.tag_red\n        else -> R.color.tag_yellow\n    }\n}\n\n// 6. Filtrowanie wed≈Çug tag√≥w:\nprivate fun filterByTag(tagName: String) {\n    val filteredTasks = if (tagName.isEmpty()) {\n        taskList\n    } else {\n        taskList.filter { it.tags.contains(tagName.lowercase()) }\n    }\n    \n    val filteredAdapter = TaskAdapter(this, filteredTasks.toMutableList())\n    listView.adapter = filteredAdapter\n}"
      },
      "en": {
        "title": "Exercise 11: Tag system",
        "description": "Add tag system to tasks. User can add custom tags (e.g. #urgent, #easy, #longterm) and filter tasks by tags. Tags should be displayed as colorful chips.",
        "hint": "Add tags field to Task class, create TagInputView for adding tags and ChipGroup for display. Implement filtering by tags.",
        "solution": "// 1. Task class modification:\ndata class Task(\n    // ... other fields ...\n    var tags: MutableSet<String> = mutableSetOf()\n) {\n    fun getTagsString(): String = tags.joinToString(\" \") { \"#$it\" }\n}\n\n// 2. Layout with ChipGroup for tags:\n<com.google.android.material.chip.ChipGroup\n    android:id=\"@+id/chipGroupTags\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"8dp\"\n    app:singleLine=\"false\" />\n\n// 3. Function to add tags to task:\nprivate fun addTagsToTask(task: Task, chipGroup: ChipGroup) {\n    chipGroup.removeAllViews()\n    \n    task.tags.forEach { tagName ->\n        val chip = Chip(this)\n        chip.text = \"#$tagName\"\n        chip.isCloseIconVisible = true\n        chip.setChipBackgroundColorResource(getTagColor(tagName))\n        \n        chip.setOnCloseIconClickListener {\n            task.tags.remove(tagName)\n            chipGroup.removeView(chip)\n            saveTasks()\n        }\n        \n        chipGroup.addView(chip)\n    }\n    \n    // Add chip for adding new tags\n    val addChip = Chip(this)\n    addChip.text = \"+ Add tag\"\n    addChip.setChipIconResource(R.drawable.ic_add)\n    addChip.setOnClickListener {\n        showAddTagDialog(task, chipGroup)\n    }\n    chipGroup.addView(addChip)\n}\n\n// 4. Add tag dialog:\nprivate fun showAddTagDialog(task: Task, chipGroup: ChipGroup) {\n    val editText = EditText(this)\n    editText.hint = \"Tag name (without #)\"\n    \n    AlertDialog.Builder(this)\n        .setTitle(\"Add tag\")\n        .setView(editText)\n        .setPositiveButton(\"Add\") { _, _ ->\n            val tagName = editText.text.toString().trim().lowercase()\n            if (tagName.isNotEmpty() && !task.tags.contains(tagName)) {\n                task.tags.add(tagName)\n                addTagsToTask(task, chipGroup)\n                saveTasks()\n            }\n        }\n        .setNegativeButton(\"Cancel\", null)\n        .show()\n}\n\n// 5. Function returning color for tag:\nprivate fun getTagColor(tagName: String): Int {\n    return when (tagName.hashCode() % 6) {\n        0 -> R.color.tag_blue\n        1 -> R.color.tag_green\n        2 -> R.color.tag_orange\n        3 -> R.color.tag_purple\n        4 -> R.color.tag_red\n        else -> R.color.tag_yellow\n    }\n}\n\n// 6. Filter by tags:\nprivate fun filterByTag(tagName: String) {\n    val filteredTasks = if (tagName.isEmpty()) {\n        taskList\n    } else {\n        taskList.filter { it.tags.contains(tagName.lowercase()) }\n    }\n    \n    val filteredAdapter = TaskAdapter(this, filteredTasks.toMutableList())\n    listView.adapter = filteredAdapter\n}"
      }
    },
    {
      "id": "exercise-12",
      "pl": {
        "title": "ƒÜwiczenie 12: Tryb offline i synchronizacja",
        "description": "Zaimplementuj tryb offline z lokalnƒÖ bazƒÖ danych Room oraz synchronizacjƒô z serwerem w tle. Aplikacja powinna dzia≈Çaƒá bez internetu i synchronizowaƒá dane po po≈ÇƒÖczeniu.",
        "hint": "U≈ºyj Room Database, WorkManager do synchronizacji w tle oraz Repository pattern do zarzƒÖdzania danymi z r√≥≈ºnych ≈∫r√≥de≈Ç.",
        "solution": "// 1. Entity dla Room:\n@Entity(tableName = \"tasks\")\ndata class TaskEntity(\n    @PrimaryKey val id: String,\n    val title: String,\n    val isCompleted: Boolean,\n    val category: String,\n    val priority: Int,\n    val dueDate: Long?,\n    val notes: String,\n    val tags: String, // JSON string\n    val lastModified: Long,\n    val isSynced: Boolean = false\n)\n\n// 2. DAO (Data Access Object):\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks ORDER BY priority DESC, lastModified DESC\")\n    fun getAllTasks(): LiveData<List<TaskEntity>>\n    \n    @Query(\"SELECT * FROM tasks WHERE isSynced = 0\")\n    suspend fun getUnsyncedTasks(): List<TaskEntity>\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: TaskEntity)\n    \n    @Update\n    suspend fun updateTask(task: TaskEntity)\n    \n    @Delete\n    suspend fun deleteTask(task: TaskEntity)\n    \n    @Query(\"UPDATE tasks SET isSynced = 1 WHERE id = :taskId\")\n    suspend fun markAsSynced(taskId: String)\n}\n\n// 3. Database:\n@Database(\n    entities = [TaskEntity::class],\n    version = 1,\n    exportSchema = false\n)\n@TypeConverters(Converters::class)\nabstract class TaskDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n    \n    companion object {\n        @Volatile\n        private var INSTANCE: TaskDatabase? = null\n        \n        fun getDatabase(context: Context): TaskDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    TaskDatabase::class.java,\n                    \"task_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}\n\n// 4. Repository:\nclass TaskRepository(private val taskDao: TaskDao, private val apiService: ApiService) {\n    \n    fun getAllTasks(): LiveData<List<TaskEntity>> = taskDao.getAllTasks()\n    \n    suspend fun insertTask(task: TaskEntity) {\n        taskDao.insertTask(task.copy(lastModified = System.currentTimeMillis()))\n        // Zaplanuj synchronizacjƒô\n        scheduleSyncWork()\n    }\n    \n    suspend fun syncWithServer() {\n        try {\n            // Wy≈õlij niezsynchronizowane zadania na serwer\n            val unsyncedTasks = taskDao.getUnsyncedTasks()\n            unsyncedTasks.forEach { task ->\n                apiService.uploadTask(task)\n                taskDao.markAsSynced(task.id)\n            }\n            \n            // Pobierz aktualizacje z serwera\n            val serverTasks = apiService.getAllTasks()\n            serverTasks.forEach { serverTask ->\n                taskDao.insertTask(serverTask.copy(isSynced = true))\n            }\n        } catch (e: Exception) {\n            // Loguj b≈ÇƒÖd, synchronizacja zostanie ponowiona p√≥≈∫niej\n        }\n    }\n    \n    private fun scheduleSyncWork() {\n        val syncRequest = OneTimeWorkRequestBuilder<SyncWorker>()\n            .setConstraints(\n                Constraints.Builder()\n                    .setRequiredNetworkType(NetworkType.CONNECTED)\n                    .build()\n            )\n            .build()\n            \n        WorkManager.getInstance().enqueue(syncRequest)\n    }\n}\n\n// 5. Worker do synchronizacji w tle:\nclass SyncWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {\n    \n    override suspend fun doWork(): Result {\n        return try {\n            val database = TaskDatabase.getDatabase(applicationContext)\n            val repository = TaskRepository(database.taskDao(), ApiService.create())\n            \n            repository.syncWithServer()\n            Result.success()\n        } catch (e: Exception) {\n            Result.retry()\n        }\n    }\n}\n\n// 6. W MainActivity u≈ºywamy LiveData:\nclass MainActivity : AppCompatActivity() {\n    private lateinit var taskRepository: TaskRepository\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val database = TaskDatabase.getDatabase(this)\n        taskRepository = TaskRepository(database.taskDao(), ApiService.create())\n        \n        // Obserwuj zmiany w bazie danych\n        taskRepository.getAllTasks().observe(this) { tasks ->\n            // Aktualizuj UI\n            updateTaskList(tasks)\n        }\n    }\n}"
      },
      "en": {
        "title": "Exercise 12: Offline mode and synchronization",
        "description": "Implement offline mode with local Room database and background server synchronization. App should work without internet and sync data when connected.",
        "hint": "Use Room Database, WorkManager for background sync and Repository pattern to manage data from different sources.",
        "solution": "// 1. Entity for Room:\n@Entity(tableName = \"tasks\")\ndata class TaskEntity(\n    @PrimaryKey val id: String,\n    val title: String,\n    val isCompleted: Boolean,\n    val category: String,\n    val priority: Int,\n    val dueDate: Long?,\n    val notes: String,\n    val tags: String, // JSON string\n    val lastModified: Long,\n    val isSynced: Boolean = false\n)\n\n// 2. DAO (Data Access Object):\n@Dao\ninterface TaskDao {\n    @Query(\"SELECT * FROM tasks ORDER BY priority DESC, lastModified DESC\")\n    fun getAllTasks(): LiveData<List<TaskEntity>>\n    \n    @Query(\"SELECT * FROM tasks WHERE isSynced = 0\")\n    suspend fun getUnsyncedTasks(): List<TaskEntity>\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertTask(task: TaskEntity)\n    \n    @Update\n    suspend fun updateTask(task: TaskEntity)\n    \n    @Delete\n    suspend fun deleteTask(task: TaskEntity)\n    \n    @Query(\"UPDATE tasks SET isSynced = 1 WHERE id = :taskId\")\n    suspend fun markAsSynced(taskId: String)\n}\n\n// 3. Database:\n@Database(\n    entities = [TaskEntity::class],\n    version = 1,\n    exportSchema = false\n)\n@TypeConverters(Converters::class)\nabstract class TaskDatabase : RoomDatabase() {\n    abstract fun taskDao(): TaskDao\n    \n    companion object {\n        @Volatile\n        private var INSTANCE: TaskDatabase? = null\n        \n        fun getDatabase(context: Context): TaskDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    TaskDatabase::class.java,\n                    \"task_database\"\n                ).build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}\n\n// 4. Repository:\nclass TaskRepository(private val taskDao: TaskDao, private val apiService: ApiService) {\n    \n    fun getAllTasks(): LiveData<List<TaskEntity>> = taskDao.getAllTasks()\n    \n    suspend fun insertTask(task: TaskEntity) {\n        taskDao.insertTask(task.copy(lastModified = System.currentTimeMillis()))\n        // Schedule synchronization\n        scheduleSyncWork()\n    }\n    \n    suspend fun syncWithServer() {\n        try {\n            // Send unsynced tasks to server\n            val unsyncedTasks = taskDao.getUnsyncedTasks()\n            unsyncedTasks.forEach { task ->\n                apiService.uploadTask(task)\n                taskDao.markAsSynced(task.id)\n            }\n            \n            // Fetch updates from server\n            val serverTasks = apiService.getAllTasks()\n            serverTasks.forEach { serverTask ->\n                taskDao.insertTask(serverTask.copy(isSynced = true))\n            }\n        } catch (e: Exception) {\n            // Log error, sync will be retried later\n        }\n    }\n    \n    private fun scheduleSyncWork() {\n        val syncRequest = OneTimeWorkRequestBuilder<SyncWorker>()\n            .setConstraints(\n                Constraints.Builder()\n                    .setRequiredNetworkType(NetworkType.CONNECTED)\n                    .build()\n            )\n            .build()\n            \n        WorkManager.getInstance().enqueue(syncRequest)\n    }\n}\n\n// 5. Worker for background sync:\nclass SyncWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {\n    \n    override suspend fun doWork(): Result {\n        return try {\n            val database = TaskDatabase.getDatabase(applicationContext)\n            val repository = TaskRepository(database.taskDao(), ApiService.create())\n            \n            repository.syncWithServer()\n            Result.success()\n        } catch (e: Exception) {\n            Result.retry()\n        }\n    }\n}\n\n// 6. In MainActivity use LiveData:\nclass MainActivity : AppCompatActivity() {\n    private lateinit var taskRepository: TaskRepository\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        \n        val database = TaskDatabase.getDatabase(this)\n        taskRepository = TaskRepository(database.taskDao(), ApiService.create())\n        \n        // Observe database changes\n        taskRepository.getAllTasks().observe(this) { tasks ->\n            // Update UI\n            updateTaskList(tasks)\n        }\n    }\n}"
      }
    },
	{
      "id": "exercise-13",
      "pl": {
        "title": "ƒÜwiczenie 13: Gestykulacja i skr√≥ty",
        "description": "Dodaj obs≈Çugƒô gest√≥w: przeciƒÖgnij w prawo aby oznaczyƒá jako uko≈Ñczone, w lewo aby usunƒÖƒá, podw√≥jne klikniƒôcie aby edytowaƒá. Dodaj te≈º skr√≥ty klawiszowe dla szybkich akcji.",
        "hint": "U≈ºyj GestureDetector, OnTouchListener i implementuj ItemTouchHelper.SimpleCallback dla gest√≥w przeciƒÖgania. Dodaj obs≈Çugƒô KeyEvent dla skr√≥t√≥w.",
        "solution": "// Doko≈Ñczenie obs≈Çugi skr√≥t√≥w klawiszowych:\n        KeyEvent.KEYCODE_F -> {\n            if (event?.isCtrlPressed == true) {\n                // Ctrl+F - wyszukaj\n                focusSearchView()\n                return true\n            }\n        }\n        KeyEvent.KEYCODE_ESCAPE -> {\n            // ESC - zamknij dialogi/filtry\n            clearAllFilters()\n            return true\n        }\n        KeyEvent.KEYCODE_DPAD_UP -> {\n            // Strza≈Çka w g√≥rƒô - poprzednie zadanie\n            selectPreviousTask()\n            return true\n        }\n        KeyEvent.KEYCODE_DPAD_DOWN -> {\n            // Strza≈Çka w d√≥≈Ç - nastƒôpne zadanie\n            selectNextTask()\n            return true\n        }\n        KeyEvent.KEYCODE_SPACE -> {\n            // Spacja - prze≈ÇƒÖcz uko≈Ñczenie wybranego zadania\n            toggleSelectedTask()\n            return true\n        }\n        KeyEvent.KEYCODE_DEL -> {\n            // Delete - usu≈Ñ wybrane zadanie\n            deleteSelectedTask()\n            return true\n        }\n    }\n    return super.onKeyDown(keyCode, event)\n}\n\n// Funkcje pomocnicze dla skr√≥t√≥w:\nprivate fun focusSearchView() {\n    val searchView = findViewById<SearchView>(R.id.searchView)\n    searchView?.let {\n        it.isIconified = false\n        it.requestFocus()\n    }\n}\n\nprivate fun clearAllFilters() {\n    currentFilter = \"Wszystkie\"\n    resetFilter()\n    clearSearchQuery()\n}\n\nprivate fun selectPreviousTask() {\n    if (selectedTaskPosition > 0) {\n        selectedTaskPosition--\n        highlightSelectedTask()\n    }\n}\n\nprivate fun selectNextTask() {\n    if (selectedTaskPosition < taskList.size - 1) {\n        selectedTaskPosition++\n        highlightSelectedTask()\n    }\n}\n\nprivate fun toggleSelectedTask() {\n    if (selectedTaskPosition >= 0 && selectedTaskPosition < taskList.size) {\n        val task = taskList[selectedTaskPosition]\n        task.isCompleted = !task.isCompleted\n        adapter.notifyItemChanged(selectedTaskPosition)\n        saveTasks()\n    }\n}\n\n// 5. Wibracja przy gestach:\nprivate fun vibrateForGesture(gestureType: GestureType) {\n    val pattern = when (gestureType) {\n        GestureType.COMPLETE -> longArrayOf(0, 50) // Kr√≥tka wibracja\n        GestureType.DELETE -> longArrayOf(0, 100, 50, 100) // Podw√≥jna wibracja\n        GestureType.EDIT -> longArrayOf(0, 30) // Bardzo kr√≥tka\n    }\n    \n    if (vibrator.hasVibrator()) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            vibrator.vibrate(VibrationEffect.createWaveform(pattern, -1))\n        } else {\n            vibrator.vibrate(pattern, -1)\n        }\n    }\n}\n\nenum class GestureType {\n    COMPLETE, DELETE, EDIT\n}"
      },
      "en": {
        "title": "Exercise 13: Gestures and shortcuts",
        "description": "Add gesture support: swipe right to mark as completed, left to delete, double tap to edit. Also add keyboard shortcuts for quick actions.",
        "hint": "Use GestureDetector, OnTouchListener and implement ItemTouchHelper.SimpleCallback for swipe gestures. Add KeyEvent handling for shortcuts.",
        "solution": "// Completion of keyboard shortcuts handling:\n        KeyEvent.KEYCODE_F -> {\n            if (event?.isCtrlPressed == true) {\n                // Ctrl+F - search\n                focusSearchView()\n                return true\n            }\n        }\n        KeyEvent.KEYCODE_ESCAPE -> {\n            // ESC - close dialogs/filters\n            clearAllFilters()\n            return true\n        }\n        KeyEvent.KEYCODE_DPAD_UP -> {\n            // Arrow up - previous task\n            selectPreviousTask()\n            return true\n        }\n        KeyEvent.KEYCODE_DPAD_DOWN -> {\n            // Arrow down - next task\n            selectNextTask()\n            return true\n        }\n        KeyEvent.KEYCODE_SPACE -> {\n            // Space - toggle selected task completion\n            toggleSelectedTask()\n            return true\n        }\n        KeyEvent.KEYCODE_DEL -> {\n            // Delete - remove selected task\n            deleteSelectedTask()\n            return true\n        }\n    }\n    return super.onKeyDown(keyCode, event)\n}\n\n// Helper functions for shortcuts:\nprivate fun focusSearchView() {\n    val searchView = findViewById<SearchView>(R.id.searchView)\n    searchView?.let {\n        it.isIconified = false\n        it.requestFocus()\n    }\n}\n\nprivate fun clearAllFilters() {\n    currentFilter = \"All\"\n    resetFilter()\n    clearSearchQuery()\n}\n\nprivate fun selectPreviousTask() {\n    if (selectedTaskPosition > 0) {\n        selectedTaskPosition--\n        highlightSelectedTask()\n    }\n}\n\nprivate fun selectNextTask() {\n    if (selectedTaskPosition < taskList.size - 1) {\n        selectedTaskPosition++\n        highlightSelectedTask()\n    }\n}\n\nprivate fun toggleSelectedTask() {\n    if (selectedTaskPosition >= 0 && selectedTaskPosition < taskList.size) {\n        val task = taskList[selectedTaskPosition]\n        task.isCompleted = !task.isCompleted\n        adapter.notifyItemChanged(selectedTaskPosition)\n        saveTasks()\n    }\n}\n\n// 5. Vibration for gestures:\nprivate fun vibrateForGesture(gestureType: GestureType) {\n    val pattern = when (gestureType) {\n        GestureType.COMPLETE -> longArrayOf(0, 50) // Short vibration\n        GestureType.DELETE -> longArrayOf(0, 100, 50, 100) // Double vibration\n        GestureType.EDIT -> longArrayOf(0, 30) // Very short\n    }\n    \n    if (vibrator.hasVibrator()) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            vibrator.vibrate(VibrationEffect.createWaveform(pattern, -1))\n        } else {\n            vibrator.vibrate(pattern, -1)\n        }\n    }\n}\n\nenum class GestureType {\n    COMPLETE, DELETE, EDIT\n}"
      }
    },
    {
      "id": "exercise-14",
      "pl": {
        "title": "ƒÜwiczenie 14: Gamifikacja i osiƒÖgniƒôcia",
        "description": "Dodaj system punkt√≥w, poziom√≥w i osiƒÖgniƒôƒá. U≈ºytkownik zdobywa punkty za uko≈Ñczone zadania, odblokowuje odznaki i awansuje na wy≈ºsze poziomy. Dodaj progress bar pokazujƒÖcy postƒôp do nastƒôpnego poziomu.",
        "hint": "Stw√≥rz system punktowania, Achievement data classes, AchievementManager do sprawdzania warunk√≥w i UI do wy≈õwietlania postƒôp√≥w.",
        "solution": "// 1. Data classes dla systemu osiƒÖgniƒôƒá:\ndata class UserProgress(\n    var totalPoints: Int = 0,\n    var currentLevel: Int = 1,\n    var tasksCompleted: Int = 0,\n    var streak: Int = 0, // Dni z rzƒôdu z uko≈Ñczonymi zadaniami\n    var lastCompletionDate: Date? = null,\n    val unlockedAchievements: MutableSet<String> = mutableSetOf()\n) {\n    fun getPointsForNextLevel(): Int {\n        return currentLevel * 100 // Ka≈ºdy poziom wymaga wiƒôcej punkt√≥w\n    }\n    \n    fun getProgressToNextLevel(): Float {\n        val pointsForCurrentLevel = (currentLevel - 1) * 100\n        val pointsForNextLevel = getPointsForNextLevel()\n        val progressPoints = totalPoints - pointsForCurrentLevel\n        val neededPoints = pointsForNextLevel - pointsForCurrentLevel\n        return (progressPoints.toFloat() / neededPoints.toFloat()).coerceIn(0f, 1f)\n    }\n}\n\ndata class Achievement(\n    val id: String,\n    val title: String,\n    val description: String,\n    val iconResource: Int,\n    val pointsReward: Int,\n    val condition: (UserProgress, List<Task>) -> Boolean\n)\n\n// 2. AchievementManager:\nclass AchievementManager {\n    \n    private val achievements = listOf(\n        Achievement(\n            \"first_task\",\n            \"Pierwszy krok\",\n            \"Uko≈Ñczy≈Çe≈õ swoje pierwsze zadanie!\",\n            R.drawable.ic_first_task,\n            10\n        ) { progress, _ -> progress.tasksCompleted >= 1 },\n        \n        Achievement(\n            \"task_master\",\n            \"Mistrz zada≈Ñ\",\n            \"Uko≈Ñczy≈Çe≈õ 50 zada≈Ñ!\",\n            R.drawable.ic_task_master,\n            100\n        ) { progress, _ -> progress.tasksCompleted >= 50 },\n        \n        Achievement(\n            \"streak_week\",\n            \"Tygodniowy streak\",\n            \"7 dni z rzƒôdu z uko≈Ñczonymi zadaniami!\",\n            R.drawable.ic_streak,\n            75\n        ) { progress, _ -> progress.streak >= 7 },\n        \n        Achievement(\n            \"high_priority_hero\",\n            \"Bohater wysokich priorytet√≥w\",\n            \"Uko≈Ñczy≈Çe≈õ 10 zada≈Ñ o wysokim priorytecie!\",\n            R.drawable.ic_priority_hero,\n            50\n        ) { _, tasks -> tasks.count { it.priority == 3 && it.isCompleted } >= 10 },\n        \n        Achievement(\n            \"category_master\",\n            \"Mistrz kategorii\",\n            \"Masz zadania w co najmniej 5 r√≥≈ºnych kategoriach!\",\n            R.drawable.ic_category_master,\n            30\n        ) { _, tasks -> tasks.map { it.category }.distinct().size >= 5 }\n    )\n    \n    fun checkForNewAchievements(progress: UserProgress, tasks: List<Task>): List<Achievement> {\n        return achievements.filter { achievement ->\n            !progress.unlockedAchievements.contains(achievement.id) &&\n            achievement.condition(progress, tasks)\n        }\n    }\n    \n    fun getAllAchievements() = achievements\n    \n    fun getUnlockedAchievements(progress: UserProgress) = \n        achievements.filter { progress.unlockedAchievements.contains(it.id) }\n}\n\n// 3. Funkcje punktowania:\nclass PointsCalculator {\n    \n    fun calculatePointsForTask(task: Task): Int {\n        var points = 10 // Podstawowe punkty\n        \n        // Bonus za priorytet\n        points += when (task.priority) {\n            3 -> 15 // Wysoki priorytet\n            2 -> 10 // ≈öredni priorytet\n            else -> 5 // Niski priorytet\n        }\n        \n        // Bonus je≈õli zadanie mia≈Ço termin\n        if (task.dueDate != null) {\n            points += 5\n            \n            // Dodatkowy bonus je≈õli uko≈Ñczono przed terminem\n            if (!task.isOverdue()) {\n                points += 10\n            }\n        }\n        \n        // Bonus za podzadania\n        if (task.subtasks.isNotEmpty()) {\n            points += task.subtasks.size * 2\n        }\n        \n        return points\n    }\n}\n\n// 4. UI dla systemu poziom√≥w:\nprivate fun updateLevelUI(progress: UserProgress) {\n    val levelText = findViewById<TextView>(R.id.textLevel)\n    val pointsText = findViewById<TextView>(R.id.textPoints)\n    val progressBar = findViewById<ProgressBar>(R.id.progressBarLevel)\n    val nextLevelText = findViewById<TextView>(R.id.textNextLevel)\n    \n    levelText.text = \"Poziom ${progress.currentLevel}\"\n    pointsText.text = \"${progress.totalPoints} punkt√≥w\"\n    \n    val progressPercent = (progress.getProgressToNextLevel() * 100).toInt()\n    progressBar.progress = progressPercent\n    \n    val pointsNeeded = progress.getPointsForNextLevel() - \n                      ((progress.currentLevel - 1) * 100)\n    val currentProgress = (progress.totalPoints - ((progress.currentLevel - 1) * 100))\n    nextLevelText.text = \"$currentProgress / $pointsNeeded do poziomu ${progress.currentLevel + 1}\"\n}\n\n// 5. Dialog nowego osiƒÖgniƒôcia:\nprivate fun showAchievementDialog(achievement: Achievement) {\n    val dialogView = LayoutInflater.from(this).inflate(R.layout.dialog_achievement, null)\n    \n    val iconView = dialogView.findViewById<ImageView>(R.id.achievementIcon)\n    val titleView = dialogView.findViewById<TextView>(R.id.achievementTitle)\n    val descriptionView = dialogView.findViewById<TextView>(R.id.achievementDescription)\n    val pointsView = dialogView.findViewById<TextView>(R.id.achievementPoints)\n    \n    iconView.setImageResource(achievement.iconResource)\n    titleView.text = achievement.title\n    descriptionView.text = achievement.description\n    pointsView.text = \"+${achievement.pointsReward} punkt√≥w!\"\n    \n    AlertDialog.Builder(this)\n        .setView(dialogView)\n        .setPositiveButton(\"≈öwietnie!\", null)\n        .show()\n    \n    // Animacja i d≈∫wiƒôk\n    playAchievementSound()\n    vibratePhone(200)\n    \n    // Animacja confetti\n    showConfettiAnimation()\n}\n\n// 6. Integracja z uko≈Ñczeniem zadania:\nprivate fun completeTask(task: Task) {\n    task.isCompleted = true\n    \n    // Oblicz punkty\n    val points = pointsCalculator.calculatePointsForTask(task)\n    userProgress.totalPoints += points\n    userProgress.tasksCompleted++\n    \n    // Sprawd≈∫ streak\n    updateStreak()\n    \n    // Sprawd≈∫ awans na wy≈ºszy poziom\n    checkLevelUp()\n    \n    // Sprawd≈∫ nowe osiƒÖgniƒôcia\n    val newAchievements = achievementManager.checkForNewAchievements(userProgress, taskList)\n    newAchievements.forEach { achievement ->\n        userProgress.unlockedAchievements.add(achievement.id)\n        userProgress.totalPoints += achievement.pointsReward\n        showAchievementDialog(achievement)\n    }\n    \n    // Zapisz postƒôp\n    saveUserProgress()\n    updateLevelUI(userProgress)\n    \n    // Poka≈º toast z punktami\n    Toast.makeText(this, \"+$points punkt√≥w!\", Toast.LENGTH_SHORT).show()\n}\n\nprivate fun checkLevelUp() {\n    val requiredPoints = userProgress.currentLevel * 100\n    if (userProgress.totalPoints >= requiredPoints) {\n        userProgress.currentLevel++\n        showLevelUpDialog()\n    }\n}\n\nprivate fun showLevelUpDialog() {\n    AlertDialog.Builder(this)\n        .setTitle(\"üéâ Awans!\")\n        .setMessage(\"Gratulacje! Awansowa≈Çe≈õ na poziom ${userProgress.currentLevel}!\")\n        .setPositiveButton(\"Wspaniale!\", null)\n        .show()\n    \n    playLevelUpSound()\n    vibratePhone(300)\n}"
      },
      "en": {
        "title": "Exercise 14: Gamification and achievements",
        "description": "Add points system, levels and achievements. User earns points for completed tasks, unlocks badges and advances to higher levels. Add progress bar showing progress to next level.",
        "hint": "Create scoring system, Achievement data classes, AchievementManager for checking conditions and UI for displaying progress.",
        "solution": "// 1. Data classes for achievement system:\ndata class UserProgress(\n    var totalPoints: Int = 0,\n    var currentLevel: Int = 1,\n    var tasksCompleted: Int = 0,\n    var streak: Int = 0, // Consecutive days with completed tasks\n    var lastCompletionDate: Date? = null,\n    val unlockedAchievements: MutableSet<String> = mutableSetOf()\n) {\n    fun getPointsForNextLevel(): Int {\n        return currentLevel * 100 // Each level requires more points\n    }\n    \n    fun getProgressToNextLevel(): Float {\n        val pointsForCurrentLevel = (currentLevel - 1) * 100\n        val pointsForNextLevel = getPointsForNextLevel()\n        val progressPoints = totalPoints - pointsForCurrentLevel\n        val neededPoints = pointsForNextLevel - pointsForCurrentLevel\n        return (progressPoints.toFloat() / neededPoints.toFloat()).coerceIn(0f, 1f)\n    }\n}\n\ndata class Achievement(\n    val id: String,\n    val title: String,\n    val description: String,\n    val iconResource: Int,\n    val pointsReward: Int,\n    val condition: (UserProgress, List<Task>) -> Boolean\n)\n\n// 2. AchievementManager:\nclass AchievementManager {\n    \n    private val achievements = listOf(\n        Achievement(\n            \"first_task\",\n            \"First Step\",\n            \"You completed your first task!\",\n            R.drawable.ic_first_task,\n            10\n        ) { progress, _ -> progress.tasksCompleted >= 1 },\n        \n        Achievement(\n            \"task_master\",\n            \"Task Master\",\n            \"You completed 50 tasks!\",\n            R.drawable.ic_task_master,\n            100\n        ) { progress, _ -> progress.tasksCompleted >= 50 },\n        \n        Achievement(\n            \"streak_week\",\n            \"Weekly Streak\",\n            \"7 consecutive days with completed tasks!\",\n            R.drawable.ic_streak,\n            75\n        ) { progress, _ -> progress.streak >= 7 },\n        \n        Achievement(\n            \"high_priority_hero\",\n            \"High Priority Hero\",\n            \"You completed 10 high priority tasks!\",\n            R.drawable.ic_priority_hero,\n            50\n        ) { _, tasks -> tasks.count { it.priority == 3 && it.isCompleted } >= 10 },\n        \n        Achievement(\n            \"category_master\",\n            \"Category Master\",\n            \"You have tasks in at least 5 different categories!\",\n            R.drawable.ic_category_master,\n            30\n        ) { _, tasks -> tasks.map { it.category }.distinct().size >= 5 }\n    )\n    \n    fun checkForNewAchievements(progress: UserProgress, tasks: List<Task>): List<Achievement> {\n        return achievements.filter { achievement ->\n            !progress.unlockedAchievements.contains(achievement.id) &&\n            achievement.condition(progress, tasks)\n        }\n    }\n    \n    fun getAllAchievements() = achievements\n    \n    fun getUnlockedAchievements(progress: UserProgress) = \n        achievements.filter { progress.unlockedAchievements.contains(it.id) }\n}\n\n// 3. Points calculation:\nclass PointsCalculator {\n    \n    fun calculatePointsForTask(task: Task): Int {\n        var points = 10 // Base points\n        \n        // Priority bonus\n        points += when (task.priority) {\n            3 -> 15 // High priority\n            2 -> 10 // Medium priority\n            else -> 5 // Low priority\n        }\n        \n        // Bonus if task had due date\n        if (task.dueDate != null) {\n            points += 5\n            \n            // Extra bonus if completed before due date\n            if (!task.isOverdue()) {\n                points += 10\n            }\n        }\n        \n        // Bonus for subtasks\n        if (task.subtasks.isNotEmpty()) {\n            points += task.subtasks.size * 2\n        }\n        \n        return points\n    }\n}\n\n// 4. UI for level system:\nprivate fun updateLevelUI(progress: UserProgress) {\n    val levelText = findViewById<TextView>(R.id.textLevel)\n    val pointsText = findViewById<TextView>(R.id.textPoints)\n    val progressBar = findViewById<ProgressBar>(R.id.progressBarLevel)\n    val nextLevelText = findViewById<TextView>(R.id.textNextLevel)\n    \n    levelText.text = \"Level ${progress.currentLevel}\"\n    pointsText.text = \"${progress.totalPoints} points\"\n    \n    val progressPercent = (progress.getProgressToNextLevel() * 100).toInt()\n    progressBar.progress = progressPercent\n    \n    val pointsNeeded = progress.getPointsForNextLevel() - \n                      ((progress.currentLevel - 1) * 100)\n    val currentProgress = (progress.totalPoints - ((progress.currentLevel - 1) * 100))\n    nextLevelText.text = \"$currentProgress / $pointsNeeded to level ${progress.currentLevel + 1}\"\n}\n\n// 5. New achievement dialog:\nprivate fun showAchievementDialog(achievement: Achievement) {\n    val dialogView = LayoutInflater.from(this).inflate(R.layout.dialog_achievement, null)\n    \n    val iconView = dialogView.findViewById<ImageView>(R.id.achievementIcon)\n    val titleView = dialogView.findViewById<TextView>(R.id.achievementTitle)\n    val descriptionView = dialogView.findViewById<TextView>(R.id.achievementDescription)\n    val pointsView = dialogView.findViewById<TextView>(R.id.achievementPoints)\n    \n    iconView.setImageResource(achievement.iconResource)\n    titleView.text = achievement.title\n    descriptionView.text = achievement.description\n    pointsView.text = \"+${achievement.pointsReward} points!\"\n    \n    AlertDialog.Builder(this)\n        .setView(dialogView)\n        .setPositiveButton(\"Awesome!\", null)\n        .show()\n    \n    // Animation and sound\n    playAchievementSound()\n    vibratePhone(200)\n    \n    // Confetti animation\n    showConfettiAnimation()\n}\n\n// 6. Integration with task completion:\nprivate fun completeTask(task: Task) {\n    task.isCompleted = true\n    \n    // Calculate points\n    val points = pointsCalculator.calculatePointsForTask(task)\n    userProgress.totalPoints += points\n    userProgress.tasksCompleted++\n    \n    // Check streak\n    updateStreak()\n    \n    // Check level up\n    checkLevelUp()\n    \n    // Check new achievements\n    val newAchievements = achievementManager.checkForNewAchievements(userProgress, taskList)\n    newAchievements.forEach { achievement ->\n        userProgress.unlockedAchievements.add(achievement.id)\n        userProgress.totalPoints += achievement.pointsReward\n        showAchievementDialog(achievement)\n    }\n    \n    // Save progress\n    saveUserProgress()\n    updateLevelUI(userProgress)\n    \n    // Show toast with points\n    Toast.makeText(this, \"+$points points!\", Toast.LENGTH_SHORT).show()\n}\n\nprivate fun checkLevelUp() {\n    val requiredPoints = userProgress.currentLevel * 100\n    if (userProgress.totalPoints >= requiredPoints) {\n        userProgress.currentLevel++\n        showLevelUpDialog()\n    }\n}\n\nprivate fun showLevelUpDialog() {\n    AlertDialog.Builder(this)\n        .setTitle(\"üéâ Level Up!\")\n        .setMessage(\"Congratulations! You advanced to level ${userProgress.currentLevel}!\")\n        .setPositiveButton(\"Awesome!\", null)\n        .show()\n    \n    playLevelUpSound()\n    vibratePhone(300)\n}"
      }
    }
	
  ],
  "additional_resources": {
    "pl": {
      "title": "Dodatkowe materia≈Çy",
      "resources": [
        {
          "title": "Oficjalna dokumentacja Android",
          "description": "Kompletny przewodnik po tworzeniu aplikacji Android w Kotlin z przyk≈Çadami kodu i najlepszymi praktykami.",
          "url": "https://developer.android.com/kotlin"
        },
        {
          "title": "Kotlin dla programist√≥w Android",
          "description": "Interaktywny kurs jƒôzyka Kotlin od JetBrains, tw√≥rc√≥w tego jƒôzyka, z naciskiem na rozw√≥j Android.",
          "url": "https://kotlinlang.org/docs/android-overview.html"
        },
        {
          "title": "Android Studio przewodniki",
          "description": "Oficjalne tutoriale Google do Android Studio z tips & tricks dla efektywnego developmentu.",
          "url": "https://developer.android.com/studio/intro"
        },
        {
          "title": "Material Design dla Android",
          "description": "Wytyczne projektowania interfejs√≥w zgodnych z Material Design od Google.",
          "url": "https://material.io/develop/android"
        },
        {
          "title": "Android Architecture Components",
          "description": "Poznaj MVVM, Room, LiveData i inne nowoczesne komponenty architektury Android.",
          "url": "https://developer.android.com/topic/architecture"
        },
        {
          "title": "Firebase dla Android",
          "description": "Kompletna platforma Google do tworzenia aplikacji mobilnych z bazƒÖ danych, uwierzytelnianiem i hostingiem.",
          "url": "https://firebase.google.com/docs/android/setup"
        },
        {
          "title": "Przyk≈Çady aplikacji Android",
          "description": "Gotowe projekty open-source do nauki i inspiracji - od prostych po zaawansowane.",
          "url": "https://github.com/android/architecture-samples"
        },
        {
          "title": "Android Testing",
          "description": "Przewodnik po testowaniu aplikacji Android - unit testy, UI testy i integracyjne.",
          "url": "https://developer.android.com/training/testing"
        },
        {
          "title": "Publikowanie w Google Play",
          "description": "Krok po kroku jak opublikowaƒá swojƒÖ aplikacjƒô w Google Play Store.",
          "url": "https://developer.android.com/distribute/google-play"
        },
        {
          "title": "Android Performance",
          "description": "Optymalizacja wydajno≈õci aplikacji Android - memory leaks, battery usage, smooth animations.",
          "url": "https://developer.android.com/topic/performance"
        }
      ]
    },
    "en": {
      "title": "Additional resources",
      "resources": [
        {
          "title": "Official Android documentation",
          "description": "Complete guide to creating Android apps in Kotlin with code examples and best practices.",
          "url": "https://developer.android.com/kotlin"
        },
        {
          "title": "Kotlin for Android developers",
          "description": "Interactive Kotlin course from JetBrains, creators of the language, focused on Android development.",
          "url": "https://kotlinlang.org/docs/android-overview.html"
        },
        {
          "title": "Android Studio guides",
          "description": "Official Google tutorials for Android Studio with tips & tricks for efficient development.",
          "url": "https://developer.android.com/studio/intro"
        },
        {
          "title": "Material Design for Android",
          "description": "Interface design guidelines compliant with Google's Material Design.",
          "url": "https://material.io/develop/android"
        },
        {
          "title": "Android Architecture Components",
          "description": "Learn MVVM, Room, LiveData and other modern Android architecture components.",
          "url": "https://developer.android.com/topic/architecture"
        },
        {
          "title": "Firebase for Android",
          "description": "Complete Google platform for building mobile apps with database, authentication and hosting.",
          "url": "https://firebase.google.com/docs/android/setup"
        },
        {
          "title": "Android app examples",
          "description": "Ready open-source projects for learning and inspiration - from simple to advanced.",
          "url": "https://github.com/android/architecture-samples"
        },
        {
          "title": "Android Testing",
          "description": "Guide to testing Android apps - unit tests, UI tests and integration tests.",
          "url": "https://developer.android.com/training/testing"
        },
        {
          "title": "Publishing to Google Play",
          "description": "Step by step how to publish your app to Google Play Store.",
          "url": "https://developer.android.com/distribute/google-play"
        },
        {
          "title": "Android Performance",
          "description": "Android app performance optimization - memory leaks, battery usage, smooth animations.",
          "url": "https://developer.android.com/topic/performance"
        }
      ]
    }
  },
  "glossary": {
    "pl": {
      "title": "S≈Çowniczek",
      "terms": [
        {
          "term": "Activity",
          "definition": "Pojedynczy ekran w aplikacji Android. Ka≈ºda Activity to klasa, kt√≥ra zarzƒÖdza interfejsem u≈ºytkownika i logikƒÖ dla konkretnego ekranu."
        },
        {
          "term": "Adapter",
          "definition": "Klasa ≈ÇƒÖczƒÖca dane (np. listƒô zada≈Ñ) z elementami interfejsu (np. ListView). T≈Çumaczy dane na elementy wizualne i zarzƒÖdza ich wy≈õwietlaniem."
        },
        {
          "term": "ListView",
          "definition": "Element interfejsu, kt√≥ry wy≈õwietla listƒô element√≥w w przewijalnym uk≈Çadzie pionowym. Ka≈ºdy element mo≈ºe mieƒá w≈Çasny layout."
        },
        {
          "term": "Toast",
          "definition": "Kr√≥tka wiadomo≈õƒá wy≈õwietlana na ekranie przez kilka sekund. Nie wymaga interakcji u≈ºytkownika i automatycznie znika."
        },
        {
          "term": "Spinner",
          "definition": "Rozwijane menu pozwalajƒÖce u≈ºytkownikowi wybraƒá jednƒÖ opcjƒô z listy dostƒôpnych opcji. Podobne do ComboBox w innych systemach."
        },
        {
          "term": "SeekBar",
          "definition": "Suwak pozwalajƒÖcy u≈ºytkownikowi wybraƒá warto≈õƒá z okre≈õlonego zakresu przez przeciƒÖganie kciuka na pasku."
        },
        {
          "term": "Data Class",
          "definition": "Specjalny typ klasy w Kotlin przeznaczony g≈Ç√≥wnie do przechowywania danych. Automatycznie generuje przydatne funkcje jak equals(), toString()."
        },
        {
          "term": "Lambda",
          "definition": "Anonimowa funkcja w Kotlin. Czƒôsto u≈ºywana do obs≈Çugi zdarze≈Ñ jak klikniƒôcia przycisk√≥w w zwiƒôz≈Çy spos√≥b."
        },
        {
          "term": "SharedPreferences",
          "definition": "Mechanizm Android do zapisywania prostych danych aplikacji (ustawienia, preferencje) w formie klucz-warto≈õƒá na urzƒÖdzeniu."
        },
        {
          "term": "Intent",
          "definition": "Obiekt u≈ºywany do uruchamiania innych Activity, us≈Çug lub przekazywania danych miƒôdzy komponentami aplikacji."
        },
        {
          "term": "Fragment",
          "definition": "Czƒô≈õƒá interfejsu u≈ºytkownika, kt√≥ra mo≈ºe byƒá osadzona w Activity. Pozwala na modularne budowanie ekran√≥w."
        },
        {
          "term": "Manifest",
          "definition": "Plik XML (AndroidManifest.xml) zawierajƒÖcy informacje o aplikacji: uprawnienia, komponenty, wersjƒô, ikonƒô itp."
        },
        {
          "term": "APK",
          "definition": "Android Package Kit - format pliku instalacyjnego aplikacji Android. Zawiera kod, zasoby i manifest aplikacji."
        },
        {
          "term": "Gradle",
          "definition": "System budowania u≈ºywany w Android Studio do kompilacji, testowania i pakowania aplikacji Android."
        },
        {
          "term": "ViewHolder",
          "definition": "Wzorzec projektowy w RecyclerView/ListView s≈Çu≈ºƒÖcy do optymalizacji wydajno≈õci przez cache'owanie referencji do widok√≥w."
        },
        {
          "term": "Notification",
          "definition": "Powiadomienie wy≈õwietlane w pasku powiadomie≈Ñ Android, informujƒÖce u≈ºytkownika o zdarzeniach w aplikacji."
        },
        {
          "term": "Widget",
          "definition": "Mini-aplikacja wy≈õwietlana na ekranie g≈Ç√≥wnym Android, pokazujƒÖca informacje lub umo≈ºliwiajƒÖca szybkie akcje."
        },
        {
          "term": "Material Design",
          "definition": "System projektowania interfejs√≥w stworzony przez Google, definiujƒÖcy wyglƒÖd i zachowanie element√≥w UI w aplikacjach Android."
        }
      ]
    },
    "en": {
      "title": "Glossary",
      "terms": [
        {
          "term": "Activity",
          "definition": "A single screen in an Android app. Each Activity is a class that manages the user interface and logic for a specific screen."
        },
        {
          "term": "Adapter",
          "definition": "A class that connects data (e.g. task list) with interface elements (e.g. ListView). Translates data into visual elements and manages their display."
        },
        {
          "term": "ListView",
          "definition": "An interface element that displays a list of items in a scrollable vertical layout. Each item can have its own layout."
        },
        {
          "term": "Toast",
          "definition": "A short message displayed on screen for a few seconds. Doesn't require user interaction and automatically disappears."
        },
        {
          "term": "Spinner",
          "definition": "A dropdown menu allowing user to select one option from a list of available options. Similar to ComboBox in other systems."
        },
        {
          "term": "SeekBar",
          "definition": "A slider allowing user to select a value from a specific range by dragging the thumb on the bar."
        },
        {
          "term": "Data Class",
          "definition": "A special type of class in Kotlin designed mainly for storing data. Automatically generates useful functions like equals(), toString()."
        },
        {
          "term": "Lambda",
          "definition": "An anonymous function in Kotlin. Often used for handling events like button clicks in a concise way."
        },
        {
          "term": "SharedPreferences",
          "definition": "Android mechanism for saving simple app data (settings, preferences) in key-value format on the device."
        },
        {
          "term": "Intent",
          "definition": "Object used to launch other Activities, services or pass data between app components."
        },
        {
          "term": "Fragment",
          "definition": "A part of user interface that can be embedded in Activity. Allows modular building of screens."
        },
        {
          "term": "Manifest",
          "definition": "XML file (AndroidManifest.xml) containing app information: permissions, components, version, icon etc."
        },
        {
          "term": "APK",
          "definition": "Android Package Kit - Android app installation file format. Contains code, resources and app manifest."
        },
        {
          "term": "Gradle",
          "definition": "Build system used in Android Studio for compiling, testing and packaging Android applications."
        },
        {
          "term": "ViewHolder",
          "definition": "Design pattern in RecyclerView/ListView used for performance optimization by caching view references."
        },
        {
          "term": "Notification",
          "definition": "Notification displayed in Android notification bar, informing user about events in the application."
        },
        {
          "term": "Widget",
          "definition": "Mini-application displayed on Android home screen, showing information or enabling quick actions."
        },
        {
          "term": "Material Design",
          "definition": "Interface design system created by Google, defining look and behavior of UI elements in Android applications."
        }
      ]
    }
  }
}